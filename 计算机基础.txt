一、数据的表示
    1、进制转换
        如果有一数为xⁿ，我们称x为基数，n为位权。
        （1）其他进制转换十进制（按权展开法）
            在按权展开时，小数点左起第一位为x⁰，小数点右起第一位为x⁻¹。
            如二进制1011.11转为十进制，
                整数部分：1*2³ + 0*2² + 1*2¹ + 1*2⁰ = 11
                小数部分：1*(2⁻¹) + 1*(2⁻²) = 0.75
                因此该数的十进制为11.75
        （2）十进制转换其他进制（短除法/除基取余法，短乘法/乘基取整法）
            如十进制11.75转为二进制，
                整数部分（短除法/除基取余法）：
                    11 / 2 = 5 余 1
                    5  / 2 = 2 余 1
                    2  / 2 = 1 余 0
                    1  / 2 = 0 余 1
                    则整数部分的二进制为，余数从下往上1011
                小数部分（短乘法/乘基取整法）：
                    0.75 * 2 = 1.5 取整 1
                    0.5  * 2 = 1   取整 1
                    则小数部分的二进制为，整数从上往下11
                因此该数的二进制为1011.11
                注意有时候小数是乘不尽的，此时只需要根据精度进行舍去即可，也就是说这些数是无法准确的用二进制进行表示的，然而计算机底层硬件的计算就是用二进制进行计算的，这也是为什么计算机中的浮点数计算会存在精度误差的问题（当然也有其他的问题，比如浮点数的对阶导致尾数移动从而精度丢失等）。
        （3）二进制与八进制、十六进制互相快速转换（三位一组，四位一组，不足补0，采用8421码快速计算）
            二进制：1010    
            八进制（三位一组）：001 010 -> 12 -> 001 010
            十六进制（四位一组）：1010 -> A -> 1010
    2、码制
        （1）原码
            最高位是符号位，其余低位表示数值的绝对值。
        （2）反码
            正数的反码与原码相同，负数的反码是其绝对值按位取反（符号位不变）。
        （3）补码
            正数的补码与原码相同，负数的补码是其反码的结果加1（符号位不变）。
        （4）移码
            补码的符号位取反。
        注：
            （1）计算机在计算的时候都是用补码进行计算的。
            （2）定点整数（纯整数，无小数）的补码、移码中类似于“1000 0000为最小负数-128而不是-0”这类是人为规定的，也是因为这个原因所以原码、反码的数码个数要比补码、移码的数码个数少1。
            （3）定点小数（纯小数，无整数）的补码、移码中类似于“1000 0000为最小负数-1而不是-0”这类是人为规定的，也是因为这个原因所以原码、反码的数码个数要比补码、移码的数码个数少1。
                数值1       数值-1      数值1 + 数值-1   定点整数范围             定点小数范围                    数码个数
        原码    0000 0001   1000 0001   1000 0010       -(2ⁿ⁻¹-1)到+(2ⁿ⁻¹-1)    -(1-2⁻⁽ⁿ⁻¹⁾)到+(1-2⁻⁽ⁿ⁻¹⁾)     2ⁿ-1
        反码    0000 0001   1111 1110   1111 1111       -(2ⁿ⁻¹-1)到+(2ⁿ⁻¹-1)    -(1-2⁻⁽ⁿ⁻¹⁾)到+(1-2⁻⁽ⁿ⁻¹⁾)     2ⁿ-1
        补码    0000 0001   1111 1111   0000 0000       -2ⁿ⁻¹到+(2ⁿ⁻¹-1)        -1到+(1-2⁻⁽ⁿ⁻¹⁾)               2ⁿ
        移码    1000 0001   0111 1111   1000 0000       -2ⁿ⁻¹到+(2ⁿ⁻¹-1)        -1到+(1-2⁻⁽ⁿ⁻¹⁾)               2ⁿ
    3、浮点数
        （1）浮点数表示
            定点整数是全为整数的数；定点小数是全为小数的数；那么浮点数就是即包含整数，又包含小数的数，表示为N = 尾数 * 基数 ^ 阶码。
            ① 一般尾数用补码表示，阶码用移码表示，但是在IEEE754标准中，尾数也可以用原码表示。
            ② 阶码的位数决定数的表示范围，位数越多范围越大。
            ③ 尾数的位数决定数的有效精度，位数越多精度越高。
            ④ 对阶时，一般都是小阶向大阶对齐，因为如果是大阶向小阶对齐，那么势必会导致大阶尾数向左移动，可能会导致最高位丢失，如果反过来则是小阶尾数向右移动，如果丢失也丢失的是最低位，这样误差会小一点。
            ⑤ 对阶是通过小阶的位数右移实现的，如果有符号位，则符号位保持不变，这也叫算术右移。
        （2）运算过程
            对阶（一般小阶向大阶对齐） -> 尾数计算 -> 结果规格化
            规格化：
                直白的来说就是要保证二进制表示时，0.5<=尾数的十进制值要<1（也就是二进制0.11....这种，小数点前只有一位而且是符号位，小数点后面第一位必须要是1），这个作用是为了保证在存储空间不变的前提下尽可能的提高浮点数表示的精度，计算机中是用二进制来存储浮点数的，尾数的存储位数是有限的，如果高位都是0这种属于无效位，反而可能会因为高位存了0，导致后面没有位数来存储本该是低位的数据，从而丢失了，如果也是0那没关系，如果不是0，那就属于精度丢失，这个时候就要用到规格化进行尾数左规，也就是左移，每左移一位阶码就要对应的减1。
    4、逻辑运算
        算术运算符：+，-，*，/
        关系运算符：<，<=，>，>=，==，!=
        赋值运算符：=
        逻辑运算符：
            逻辑与&&，AND（两个都为真才为真）
            逻辑或||，OR（两个中有一个为真就为真）
            逻辑非!，NOT（逻辑值取反）
            逻辑异或⊕，XOR（两个相同为假，不同为真）
        优先级：
            非 > 算术运算符 > 关系运算符 > 与 > 或 > 赋值运算符
        短路原则：
            在逻辑表达式的计算中，并不是所有的逻辑运算符都要被执行。
            （1）a&&b&&c，只要a为假，不会计算后面的值。
            （2）a||b||c，只要a为真，不会计算后面的值。
二、校验码
    计算机中数据的传递是通过二进制数据传递的，如果我们事先知道的某些数据位是出错的，那么我们就可以通过出错的数据位取反来实现纠错。
    码距：任何一种编码都是由许多码字构成，任意两个码字之间最少变化的二进制位数，就称为数据校验码的码距。比如两位二进制可以有{00,01,10,11}这四种码字，码距为最少变化为2。
    1、奇偶校验码
        可以检查“奇数个数据位”出错，但是不可以纠错。
        奇校验：整个信息（信息位拼接校验位）中“1”的个数为奇数。
        偶校验：整个信息（信息位拼接校验位）中“1”的个数为偶数。
        比如男0 女1，举例奇校验信息拼接校验码后就是男10，女01，如果接收到的消息为男00，女11就可以知道数据发生了错误，但是如果接收到的消息为男01，女10，这种情况数据出现了错误但是奇校验无法识别；偶校验同理。
    2、CRC循环冗余校验码
        可以检错，不可以纠错。
        CRC的编码方式是：在x位信息码之后拼接y位校验码。校验码的位数由生成多项式决定，这个多项式是发送方和接收方约定的。把接收到的CRC码用约定的生成多项式去除（模二除法），如果正确则余数为0，如果某一位出错，则余数不为0。不同的位数出错其余数不同，余数和出错位序号之间有唯一的对应关系。
    3、海明校验
        可以检错，也可以纠错。
        在信息位中加入几个校验位新城海明码，使码距比较均匀地扩大，并把海明码的每个二进制位分配到几个奇偶校验组中，当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错误，还能指出错误的位置，为自动纠错提供了依据。
        校验位求取公式 2^r>=m+r+1，其中m是信息位的个数，r是最少校验位的个数。
        假如需要传递的信息位是16位，若要使式子成立，则r>=5，即最少需要5位校验码，分别将校验码放到信息的2⁰，2¹，2²，2³，2⁴位上（也就是2的阶乘1 2 4 8 16 32...）。
    总结：
                        校验码位数              校验码位置          检错                       纠错    校验方式
    奇偶校验             1                      一般拼接在头部      可以检查“奇数个数据位”出错   不可以  参考上面
    CRC循环冗余校验      生成多项式最高次幂决定   拼接在信息尾部      可以检错                    不可以  模二除法求余数，拼接为校验位
    海明校验             2^r>=m+r+1             插入在信息位中间    可以检错                    可以    分组奇偶校验
三、CPU组成
    CPU主要由运算器、控制器、寄存器和内部总线等部件组成。
    运算器：
        （1）算术逻辑单元ALU：数据的算术运算和逻辑运算。
        （2）累加寄存器AC：通用寄存器，为ALU提供一个工作区，用在暂存数据。
        （3）数据缓冲寄存器DR：写内存时，暂存指令或数据。
        （4）状态条件寄存器PSW：存状态标志与控制标志。（也可以属于控制器，有争议，归类时放在最后考虑）
    控制器：
        （1）程序计数器PC：存储下一条要执行指令的地址（每执行一条指令，计数器就加一，就是一段程序的每一条指令的地址）。
        （2）指令寄存器IR：存储即将执行的指令。
        （3）地址寄存器AR：存储当前CPU所访问的内存单元的地址（就是一段程序的头地址）。
        （4）指令译码器ID：对指令中的操作码字段进行分析解释。
        （5）时序部件：提供时序控制信号。
四、寻址方式
    （1）立即寻址方式：操作数直接放在指令中，速度快，灵活性差。（比如常量）
    （2）直接寻址方式：指令中存放的是操作数的地址。（比如变量）
    （3）间接寻址方式：指令中存放了一个地址，这个地址对应的内容是操作数的地址。（比如多级指针）
    （4）寄存器寻址方式：寄存器存放操作数。（存在寄存器的常量）
    （5）寄存器间接寻址方式：寄存器存放的是操作数的地址。（存在寄存器的变量，也可以是多级指针）
五、CISC与RISC
                            RISC（精简指令集）                  CISC（复杂指令集）
    指令种类                少                                  多
    指令复杂度              简单                                复杂
    指令长度                固定                                变化
    寻址方式                少                                  多
    实现（译码）方式        硬布线控制逻辑（组合逻辑控制器）        微程序控制技术
    通用寄存器数量          多                                  一般
    流水线技术              支持，更适合流水线技术               支持
六、流水线技术
    流水线是指在程序执行时，多条指令重叠进行操作的一种“准并行”处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。
    第一条指令执行的时间我们称为流水线建立时间。之后的每个指令完成的时间我们称为流水线周期，为拆分的所有步骤中执行时间最长的一段。
    （1）流水线执行时间理论公式：(t1+t2+...+tk) + (n-1)*t
    （2）流水线执行时间实践公式：k*t + (n-1)*t
    这里的k代表一条指令执行过程可以分解为k个步骤；t为流水线周期；n为流水线周期数。
    1、为什么会有理论公式和实践公式的区别？
        理论公式中的第一条指令每个步骤执行完成后会立刻接上第二条指令的对应步骤（如果满足执行条件），所以直接相加每个步骤的执行时间，但是实际中很显然不可能立刻接上，因为还涉及到指令寻址耗时等等所以会有冗余时间，所以就要取所有步骤中时间最长的一段作为每个步骤的时间，所以才会变成k*t。
    2、为什么流水线技术取所有步骤中执行时间最长的一段作为流水线周期？
        流水线技术就是上一个指令的第一个步骤执行完之后就会执行第二个指令的第一个步骤，如果此时第一个指令的第二个步骤执行时间小于第二个指令的第一个步骤，那么即便它执行完成也不会去立即去执行第二个指令的第二个步骤，必须空等直到第二个指令的第一个步骤执行完毕，这就是为什么流水线周期要取所有步骤中执行时间最长的一段（因为存在空等）。
    3、流水线吞吐率计算。
        流水线吞吐率是指在单位时间内流水线所完成的任务数量或输出的结果数量。
        基本公式为：TP = 指令条数 / 流水线执行时间。
        吞吐率公式为（吞吐率公式的时间用的是理论公式）：n / (t1+t2+...+tk) + (n-1)*t
        最大吞吐率公式为（最大吞吐率公式的时间用的是实践公式）：n / (k+n-1)*t 可以求个极限近似看为 1/t
七、存储系统
    1、层次化存储结构
        外存（辅存）：硬盘、光盘、U盘；速度最慢，容量最大，常见T级别。
        内存（主存）：随机存储器RAM、只读存储器ROM；速度较慢，容量较大，常见G级别。
        Cache：高速缓冲存储器；速度较快，容量较小，常见M级别。
        CPU：寄存器；速度最快，容量最小，常见bit级别。

        虚拟存储体系指的是内存和外存的组合。
        三级存储体系指的是内存和外存和Cache的组合。
        
        局部性原理是层次化存储结构的支撑。
        （1）时间局部性：如果一个内容近期被访问，那么在将来它可能再次被访问。体现在程序中的循环体。
        （2）空间局部性：如果一个内容被访问了，那么它附近的内容也可能很快被访问。体现在程序中的顺序结构，如数组。

        分类：
            （1）存储器位置
                内存和外存
            （2）存取方式
                按内容存储：
                    相联存储器（如Cache），相联存储器是一种不根据地址，而是根据存储内容来进行存取的存储器（注意不可以简单的理解为哈希存储）。
                按地址存储：
                    随机存储器：如内存。
                    顺序存储器：如磁带，不能跳，不能倒。
                    直接存储器：如磁盘，磁盘的读写分三步，①移臂定位，②延时等待，③读写，第一步就是随机存储，第二步就是顺序存储，它结合了两种类型。
            （3）工作方式
                随机存储器RAM：如内存（DRAM动态随机存储器，SRAM静态随机存储器），内容掉电会丢失。
                只读存储器ROM：如BIOS所在的主板上面的ROM芯片，内容掉电保留。注意硬盘HDD，或者固态硬盘SDD，它不属于ROM；另外现在有一种叫做EEPROM电可擦可编程只读存储器，这种ROM是允许写入的，这种擦除和写入都是有一定的寿命限制。EPROM叫做可擦除可编程只读存储器，它与EEPROM的区别是，EPROM是用紫外线来擦除的，EEPROM是用电来擦除的，EPROM已经被EEPROM取代。
                DRAM集成率相对较低，功耗相对较大，需要动态刷新。
                SRAM集成率相对较高，功耗相对较小，不需要动态刷新。
    2、Cache
        在计算机存储系统体系中，Cache是速度最快的（如果有寄存器，寄存器最快，寄存器是在CPU里面的，而Cache位于CPU和主存之间）。

        使用Cache改善系统性能的依据是程序的局部性原理，局部性原理参考“层次化存储结构”。

        如果访问的数据刚好在Cache中就叫缓存命中，否则就叫缓存未命中。
        
        平均周期时间的计算是通过加权平均值来求取的，即：
            缓存命中的概率 * Cache的周期时间 + 缓存未命中的概率 * 主存周期时间 = Cache+主存的平均周期时间

        地址映像是将主存与Cache的存储空间划分为若干大小相同的页（或称为块），然后把主存的页映射到Cache的页中。Cache和主存之间的地址映像是由硬件直接完成的。这种映射有三种形式：
            （1）直接相联映像：硬件电路较简单，但冲突率高，有点类似哈希映射的直接映射。
            （2）全相联映像：电路难于设计和实现，只适用于小容量的Cache，冲突率较低，有点类似哈希映射的线性探测。
            （3）组相联映像：直接相联和全相联的折中，有点类似分组过后，每组内进行哈希映射的线性探测。
    3、主存编址计算
        存储单元个数 = 最大地址 - 最小地址 + 1

        编制内容：
            按字编址：存储体的存储单元室字存储单元，也就是最小寻址单位是一个字。
            按字节编址：存储体的存储单元是字节存储单元，也就是最小寻址单位是一个字节。

        总容量 = 存储单元个数 * 编址内容（存储单元长度）

        根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出芯片的总数，即：
            总片数 = 总容量 / 每片的容量
八、输入输出技术
    1、数据传输控制方式
        （1）程序控制方式：分为分为无条件传送和程序查询传送方式两种。方法简单，硬件开销小，但IO能力不高，严重影响CPU的利用率。
        （2）程序中断方式：与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。当IO系统准备好以后，发出中断信号通知CPU；CPU接收到中断信号后，保存正在执行程序的现场（现场信息保存在一个栈数据结构中），打断的程序当前位置即为断点；通过中断向量表（保存发出中断信号的服务程序的入口地址），转入IO中的服务程序的执行，完成IO系统的数据交换；返回被打断的程序继续执行。（鼠标和键盘使用的方式）
        （3）DMA方式：DMA是直接内存访问，是为了在主存和外设之间实现高速、批量数据交换而设置的。DMA方式不需要CPU执行程序指令来传送数据，比上述两种方式都高效。DMAC向总线裁决逻辑提出总线请求，CPU执行完当前总线周期即可释放总线控制权，此时DMA响应，通过DMAC通知IO接口开始DMA传输。（移动硬盘使用的方式）
        （4）通道方式
        （5）IO处理机
        从上往下效率越来越高。
九、总线系统
    一条总线同一时刻仅允许一个设备发送，但允许多个设备接受（分时双工）。
    并行总线适合近距离数据传输，串行总线适合长距离数据传输，总线因为是分时双工的特性，所以性能是没有全双工的性能高的，总线在设计上可以与连接设备实现最佳匹配。
    
    总线的分类
        （1）数据总线（DB）：在CPU和RAM之间来回传送需要处理或是需要储存的数据。
        （2）地址总线(AB)：用来指定在RAM中储存的数据的地址。
        （3）控制总线(CB)：将微处理器控制单元（CU）的信号传送到周边设备。

    系统总线主要用于CPU、主存及外设部件的连接。
十、可靠性
    可靠性关注的是系统的故障率。
    可用性关注的是系统的可用时长。
    串联系统可靠性是各模块可靠性的乘积。
    并联系统可靠性是1-各模块不可靠性的乘积。
    假如某个部件用在1000台机器上，运行工作1000小时后，其中有4台机器该部件故障，则该部件的千小时可靠度为：(1000 - 4) / 1000。
十一、性能指标
    1、字长和数据通路宽度：字长是计算机一次能够读取的数据长度，如果考虑地址总线的字长，对于32个bit的字长能够表示的地址范围是2³²，也就是4个G的大小，也就是当主存为4G时一般用32位操作系统；数据通路宽度指的是数据总线一次能够通过的数据量。
    2、主存容量和存取速度：内存的大小和内存的读写速度，包括外设和内存的读写速度。
    3、主频与CPU时钟周期：主频是数据一秒钟在数据总线中通过的次数；CPU时钟周期是数据每一次通过数据总线所花费的时间；如果主频是2.4GHZ，那么时钟周期就是1/2.4GHZ。
    4、运算速度：CPI每条指令所占据的时钟周期；IPC每个时钟周期能够完成的指令条数；MIPS百万条指令每秒；MFLOPS百万个浮点数操作每秒。
    5、吞吐量与吞吐率：吞吐量表示每一个时间间隔所完成的任务量；吞吐率表示单位时间内所完成的任务量；当时间间隔是一个单位时间的时候，吞吐量和吞吐率的概念没有太大的区分。
    6、响应时间与完成时间：响应时间是请求提交后到完成请求的时间叫响应时间；完成时间是事务或者指令执行完成的时间。
    7、兼容性：软件考虑兼容性，开发软件时一般向下兼容操作系统。
十二、操作系统
    1、操作系统的作用
        应用程序-》系统程序-》操作系统-》计算机硬件（裸机）
        
        操作系统管理系统的硬件、软件、数据资源。
        操作系统控制程序运行。
        操作系统是人机交互的接口。
        操作系统是应用软件与硬件之间的接口。

        操作系统对软硬件的管理：
            （1）进程管理
            （2）存储管理
            （3）文件管理
            （4）作业管理
            （5）设备管理
    2、特殊的操作系统
        （1）批处理操作系统
            单道批：一次一个作业入内存，作业由程序、数据、作业说明书组成。
            多道批：一次多个作业入内存，多道、宏观上并行微观上串行。
        （2）分时操作系统
            采用时间片轮转的方式为多个用户提供服务，每个用户感觉独占系统，多路性、独立性、交互性和及时性。
        （3）实时操作系统
            实时控制系统和实时信息系统，交互能力要求不高，可靠性要求高（规定时间内响应并处理）。
        （4）网络操作系统
            方便有效共享网络资源，提供服务软件和有关协议的集合。主要的网络操作系统有Unix、Linux和Windows Server系统。
        （5）分布式操作系统
            任意两台计算机可以通过通信交换信息，是网络操作系统的更高级形式，具有透明性、可靠性和高性能等特性。
        （6）微机操作系统
            就是微型计算机也就是PC机，Windows、Linux。
        （7）嵌入式操作系统
            运行在智能芯片环境中，微型化、可定制（针对硬件变化配置）、实时性、可靠性、易移植性（体现在HAL和BSP支持）。
十三、进程
    1、进程/线程/协程的概念
        进程：是操作系统进行资源分配的基本单位。它有程序块、进程控制块（PCB，PCB是进程存在的唯一标志，内容包含进程标识符、状态、位置信息、控制信息、队列指针（链接同一状态的进程）、优先级、现成保护区等）和数据块三部分组成。进程是程序的一次执行过程，没有程序就没有进程，程序是一个静态的概念，而进程是一个动态的概念。
        
        线程：是CPU进行调度的基本单位。进程独立拥有资源，线程可以共享资源，可以共享内存地址空间、代码、数据、文件等，不会共享程序计数器、寄存器、栈等。每一个CPU的逻辑核心可以执行一个线程。一个进程可以包含多个线程。

        协程：协程也叫做微线程或纤程，协程运行在线程中，协程的调度完全由用户程序自行控制，称为用户级别的线程。在CPU多逻辑核心下，线程可以同时运行多个，但是协程只能运行一个，这既是因为协程运行在线程里，而线程是CPU调度的基本单位，又是因为协程设计上是通过协作来完成任务的，在任意时刻只有一个协程在运行，协程的调度显式的写在代码中，多个协程顺序执行完成任务。
    2、进程的状态
        （1）三态模型：
            运行状态：当一个进程得到CPU资源在CPU上运行时，CPU时间片到时会重回就绪状态，等待事件发生会变为阻塞状态。（单处理机处于运行态的进程只有一个）
            就绪状态：一个进程获得了除CPU资源以外的一切所需资源，一旦得到CPU资源即可运行。
            阻塞状态：也称等待或睡眠状态，一个进程正在等待某一个事件发生（例如请求IO，等待IO完成时）而暂时停止运行，此时即使把CPU资源分配给该进程也无法运行，故称进程处于阻塞状态，当等待事件完成时会变为就绪状态，等待CPU资源的分配。
        （2）五态模型：相对于三态模型主要是多了一个挂起和唤醒的操作。
            运行状态：可以通过挂起变为禁止就绪状态，可以通过CPU时间片到时变为活跃就绪状态，可以通过等待事件发生变为活跃阻塞状态。
            静止就绪（挂起就绪）状态：可以通过唤醒变为活跃就绪状态。
            活跃就绪（就绪）状态：可以通过挂起变为禁止就绪状态，可以通过CPU调度变为运行状态。
            静止阻塞（挂起阻塞）状态：可以通过等待事件完成变为静止就绪状态，可以通过唤醒变为活跃阻塞状态。
            活跃阻塞（阻塞）状态：可以通过等待事件完成变为活跃就绪状态，可以通过挂起变为静止阻塞状态。

            也就是
                通过挂起把活跃状态变为静止状态，通过唤醒把静止状态变为活跃状态；
                通过等待事件发生把就绪状态变为阻塞状态，通过等待事件完成把阻塞状态变为就绪状态；
                通过获得CPU资源把就绪状态变为运行状态，通过CPU时间片到时把运行状态变为就绪状态；
                另外，通过等待事件发生把运行状态变为活跃阻塞状态，通过挂起把运行状态变为静止就绪状态；

            挂起原因：
                ① 进程过多，主存资源不足，此时必须将某些进程挂起，放到磁盘对换区，暂时不参与调度以平衡系统负载。
                ② 系统出现故障，或者用户调试程序，也可能需要将进程挂起检查问题。
    3、进程的调度
        （1）PV操作的概念
            临界资源：在并发的情况下，进程间需要互斥方式访问的共享资源叫做临界资源。
            临界区：进程中访问临界资源的那段代码称为临界区。
            互斥：对于同一个资源，A访问时，B不能访问。
            同步：对于同一个资源，需要AB同时访问，但是AB的速度有差异，需要在一定情况下停下等待。

            信号量S是一种特殊的变量，在代码中是一个全局变量，信号量可以表示资源的数量，信号量为负数时还可以表示排队的进程数。
            P操作指的是加锁的过程P(S)，减信号量，判断，先s=s-1，然后判断s<0，为真则进入阻塞队列，为假则往下进行。
            V操作指的是解锁的过程V(S)，加信号量，判断，先s=s+1，然后s<=0，为真则唤醒阻塞队列中的进程，为假则往下进行。
            PV操作一定是成对出现的。
        （2）信号量与PV操作
            互斥模型：如多进程使用同一个打印机，A进程在使用打印机之前要对打印机资源进行P操作，使用完打印机之后再对打印机资源进行V操作。

            同步模型：如生产者、消费者、缓冲区，生产者将资源放到缓冲区之前要对“缓冲区的剩余空间S1”进行P操作，资源放到缓冲区之后再对“资源S2”进行V操作，消费者在从缓冲区获取资源之前要对“资源S2”进行P操作，从缓冲区获取资源之后再对“缓冲区的剩余空间S1”进行V操作。这里可以看出PV操作虽然是成对出现的，但是也可以跨代码段成对出现。

            互斥同步模型：如果上述的生产者消费者问题中，要求缓冲区同时只能被一个进程访问，那么此时就变成了互斥同步模型，相对于同步模型里的生产者消费者问题，就变成了生产者在生产的时候，消费者是不能消费的（即便消费者有足够的资源），那么就需要在生产者的资源放到缓冲区的操作前后分别对“缓冲区资源S3”进行PV操作，在消费者从缓冲区获取资源前后分别对“缓冲区资源S3”进行PV操作。
        （3）前趋图与PV操作
            前趋图指的是节点与节点之间有明显的先后关系的图，也就是有向无循环图，也就是拓扑图。

            有前驱节点的操作需要先通过P操作来检查前驱操作是否完成，前驱操作执行完成后通过V操作来通知后继节点来执行。这也是一个同步模型。
十四、死锁资源数计算
    死锁指的是两个以上的进程互相都要求对方已经占有的资源导致无法继续运行下去的现象。

    死锁四大条件：
        1、互斥:A和B互斥持有资源。
        2、持有和等待：A持有资源等待剩余的资源。
        3、不可剥夺：A无法剥夺B持有的资源。
        4、环路等待：A等B，B等A。

    如果要预防死锁，可以打破死锁的四大条件。比如：
        1、有序资源分配法：有序的分配资源，先给A分配，A满足之后再给B分配。
        2、静态资源分配法：根据已知的资源需求进行分配，优先满足已知的资源需求。

    死锁的避免可以通过银行家算法来避免，银行家算法运用到操作系统中，就是当一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再通过安全性检查算法（安全性检查算法指的是对于系统中的每一个进程，判断它以后需要的资源量不超过系统当前剩余资源量与当前所有进程所占有的资源量的之和，我们称系统是安全的，安全状态一定没有死锁发生，不安全状态不一定会发生死锁）进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态，如果不会才将资源分配给它，否则让进程等待。

    另外还可以采用鸵鸟策略对死锁情况不予理睬，在某些情况下可以进行硬等待来等到资源。

    系统“不可能发生死锁”的最小资源数公式：(每个进程需求资源数 - 1) * 进程数 + 1 <= 系统资源数
十五、进程资源图
    图例：
        圆圈P：进程P
        矩形圆圈R1：资源R1，内部有几个圆圈就有几个R1
        矩形圆圈R1->圆圈P：资源R1已经分配给进程P，1个箭头即分配了1个R1
        矩形圆圈R1<-圆圈P：进程P申请1个资源R1，1个箭头即申请了1个R1，等待R1分配
    先分析资源分配情况，列出剩余可用资源，再判断申请后进程能否成功执行，注意执行完成后会释放资源。如果让你判断进程资源图的某个进程节点是非阻塞节点还是阻塞节点，要注意这里看的是进程资源图的静态过程，不看动态过程，不要考虑A非阻塞释放了资源可以给B用，只有判断是不是死锁图才会有这样的动态过程。
    详情图例可看：https://www.bilibili.com/video/BV13U4y1E7oA，第P37节，进程资源图
十六、段页存储
    1、页式存储
        将程序与内存划分为同样大小的页，以页为单位将程序调入内存，具体的划分页号（逻辑）和实际内存中的页帧号（物理）的映射关系被记录在一张页表中。
        
        页表由页号，物理块号（物理块号又称页帧号），状态位（是否在内存中），访问位（最近是否被访问），修改位（内容是否被修改过）组成。

        逻辑地址 = 页号 拼接 页内地址
        物理地址 = 页帧号 拼接 页内地址

        逻辑地址转物理地址，其中页内地址是不变的，只需要查页表将页号转成页帧号即可，例如：
            页式存储系统中，每个页的大小为4KB，根据主存编址计算公式，
                总容量 = 存储单元个数 * 编址内容（存储单元长度）
            没有告诉编址内容，默认按字节编址，也就是每个存储单元为1B，总共有4KB的总容量，则存储单元个数有4K个，也就是4096个，对于4096个也就是2¹²个存储单元进行编址，这个容量需要12个二进制来进行地址编码，题目给出了已知的逻辑地址，
                10 1100 1101 1110
            已知编址只需要12位，所以最高两位10就代表的是页号，也就是2，通过查表得到页帧号，将页帧号转换成二进制拼接在页内地址之前就可以得出物理地址。

        页式存储的优点是内存利用率高，碎片小，分配及管理简单。
        页式存储的缺点是增加了系统开销，并且可能会产生抖动现象（某一个页被经常的调入调出内存，比如一段连续的代码被从中间截断分页了，两个页面其中一个在用前又被淘汰了，那么就可能导致淘汰的那个页面频繁的调入调出内存）。

        如果在分页的过程中，分出的页不够用，就会发生缺页中断，此时会将已有的页从内存中淘汰出去，然后将新的页调入进来解决缺页的问题。

        页淘汰原则：
            （1）淘汰访问位为0（依据时间局部性原理，如果一个页最近被访问过，那么它在将来很有可能会再次被访问）。
            （2）如果多个访问位为0，就淘汰修改位为0的。

        页置换算法：
            （1）最优算法：理想型的算法，对于一个事件发生前无法决定哪种情况最优，但可以用作基准算法来对比其他算法。
            （2）随机算法。
            （3）先进先出算法：有可能会产生抖动现象。
            （4）最近最少使用算法：不会产生抖动现象，依据空间局部性原理，如果一个页最近被访问过，那么这个页临近的页很有可能很快也被访问。
    2、段式存储
        在页式存储中，很有可能会出现将一个连续的代码段从中间进行拆开分页，这会变成两个页AB，假如调入A到内存中，但是B被淘汰了，这就会导致B被重复调入，为了解决这种逻辑上连续，但是调用上分散的情况，可以使用段式存储。

        段式存储按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样。逻辑空间和物理空间的映射被记录在一张段表中。

        段表由段号，段长，基址组成。

        逻辑地址由段号，段内偏移量组成（段内偏移量不能超过段长，称为合法段地址，否则为非法段地址）。

        逻辑地址转物理地址，通过段号在段表中查到基址位置，然后用基址加上段内偏移量即可得到物理地址。

        段式存储的优点是多道程序共享内存，各段程序修改互不影响。
        段式存储的缺点是内存利用率低，内存碎片浪费大。
    3、段页式存储
        段式存储与页式存储的综合体。先分段，再分页。一个程序有若干个段，每个段中可以有若干页，每个页的大小相同，但每个段的大小不同。具体计算参考第2条。
十七、磁盘管理
    一个磁盘可以有多个盘面（或者叫柱面），盘面分为磁道（每一个同心圆）和扇区（每一个单位角度的扇形区域），每一个盘面都有一个磁头进行读写，所有的磁头都在主杆上面。
    磁盘的读写分三步，①移臂定位，②延时等待，③读写。
    存取时间 = 寻道时间 + 等待时间 + 读写时间
    寻道时间就是磁头移动到磁道所需的时间。
    等待时间就是等待读写的扇区转到磁头下方所用的时间。

    移臂调度算法：
        （1）先来先服务算法
        （2）最短寻道时间优先算法：站在当前磁道，寻找离它最近的磁道。
        （3）扫描算法（电梯算法）：从最外到最内，最内到最外，双向扫描。
        （4）循环扫描算法：要么从最外到最内，要么从最内到最外，单向扫描。

    注意，使用缓冲区进行磁盘读写，处理数据的题，大概率都是要用到第六节的“流水线技术”的。
十八、IO管理软件
    IO管理软件分层：
        用户进程
        设备无关程序
        设备驱动程序
        中断处理程序
        硬件
    IO请求从上往下，IO应答从下往上。
    
    用户级IO层：发出IO调用。
    设备无关IO层：设备名解析、阻塞进程、分配缓冲区。
    设备驱动程序：设置寄存器，检查设备状态。
    中断处理程序：IO完成后唤醒设备驱动程序。
    硬件：完成具体的IO操作。
十九、文件管理
    1、文件相关概念
        （1）文件：具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合。
        （2）逻辑结构：有结构的记录式文件、无结构的流式文件。
        （3）物理结构：连续结构、链接结构、索引结构、多个物理块的索引表。
        （4）文件目录：
            ① 基本信息类：文件名、文件的物理地址、文件长度和文件块数等。
            ② 存储控制信息类：
                文件的存储权限：读、写、执行权限等。
                文件属性：只执行、隐藏、只读、读/写、共享、系统。
            ③ 使用信息类：文件建立日期、最后一次修改/访问日期、当前使用的信息、打开文件的进程数以及在文件上的等待队列等。
        （5）目录结构
            一级目录结构：线性结构，查找速度慢，不允许重名和实现文件共享等。
            二级目录结构：主文件目录（MFD）+用户目录（UFD）。
            三级目录结构：树形目录结构（多级目录结构）。

        注意，文件目录的崩溃对操作系统的影响是相对较大的。
    2、树形目录结构
        绝对路径：是从盘符（根目录）开始的路径。
        相对路径：是从当前目录开始的路径。
        全文件名：绝对路径+文件名。
    3、位示图
        用二进制的一位来表示一个磁盘中的一个物理块可用还是不可用，这样的二进制所组成的集合叫做位示图。
        没有明确说明，默认位从0开始编号，字从1开始编号。
        假如有一个300GB的磁盘，这个磁盘每一个物理块的大小为1MB，那么共有307200个物理块，给定一个字长为32位，参考主存编址计算公式，总容量 = 存储单元个数 * 编址内容（存储单元长度），编址内容就是32，要编址307200个物理块就等于总容量是307200，那么就需要307200/32=9600个存储单元，也就是需要9600个字。
    4、索引文件
        文件系统的索引结构是由索引表，索引块，物理块（数据块）构成的。
        
        索引表由索引节点组成，物理块的逻辑块号按照索引节点从小到大顺序递增（也就是物理块的逻辑块号是按顺序的），索引节点和逻辑块号都是从0开始编码的。

        直接索引：索引节点存储的是物理块的地址。
        一级间接索引：索引节点存储的是一级索引块的地址，一级索引块存储的是物理块的地址。
        二级间接索引：同理。
        三级间接索引：同理。
二十、作业管理
    1、作业状态
        可以参考进程的五态模型
    2、作业调度算法
        （1）先来先服务法
        （2）时间片轮转法
        （3）短作业优先法
        （4）最高优先权优先法：作业标记优先权，高优先权先响应，默认优先权一样。
        （5）高响应比优先法：将作业的响应比求出，高响应比优先执行。
        响应比 = (作业等待时间 + 作业执行时间) / 作业执行时间
二十一、数据库的基本概念
    1、数据库体系结构
        （1）集中式数据库系统：数据是集中的；数据管理是集中的；数据库系统的功能（从形式的用户接口到DBMS核心）都集中在DBMS所在的计算机。
        （2）Client/Server结构：客户端负责数据表示服务；服务器主要负责数据库服务；数据库系统分为前端和后端；ODBC、JDBC；
        （3）分布式数据库：物理上分布、逻辑上集中；物理上分布、逻辑上分布；特点；透明性；
        （4）并行数据库：共享内存式；无共享式；

        分布式数据库特点：
            （1）数据独立性：除了数据的逻辑独立性与物理独立性外，还有数据分布独立性（分布透明性）；
            （2）集中与自治共享结合的控制结构：各局部的DBMS可以独立地管理局部数据库，具有自治的功能。同时，系统又设有集中控制机制，协调各局部DBMS的工作，执行全局应用。
            （3）适当增加数据冗余度：在不同的场地存储同一数据的多个副本，可以提高系统的可靠性和可用性，同时也能提高系统性能。（提高系统的可靠性和可用性，即当系统中某个节点发生故障时，因为数据有其他副本在非故障场地上，对其他所有场地来说，数据仍然是可用的，从而保证数据的完备性。）
            （4）全局的一致性、可串行性和可恢复性。

        分布式数据库透明性：
            （1）分片透明：用户不必关心数据是如何分片的，它们对数据的操作在全局关系上进行，即如何分片对用户是透明的。
            （2）复制透明：用户不必关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。
            （3）位置透明：用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。
            （4）局部映像透明性（逻辑透明）：是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关系局部DBMS支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。
        
        DBMS：数据库管理系统。
    2、三级模式和两级映射
        （1）（视图级）外模式，或用户模式
        （2）外模式-模式映射：逻辑独立性，数据的逻辑结构发生变化后，用户程序不用修改，但是为了保证应用程序能够正确执行，需要修改外模式和概念模式之间的映射。用户视图，用于概念级数据库。
        （3）（表级）模式，或概念模式
        （4）模式-内模式映射：数据独立性，当数据的物理结构发生改变时，应用程序不用改变，但是为了能够保证应用程序能够正确执行，需要修改概念模式和内模式之间的映射。DBA视图，用于物理级数据库。
        （5）（文件级）内模式，或存储模式
    3、数据仓库
        面向主题：数据按主题组织。
        集成的：消除了源数据中的不一致性，提供整个企业的一致性全局信息。
        相对稳定的（非易失的）：主要进行查询操作，只有少量的修改，几乎不删除（或者不删除）。
        反映历史变化（随着时间变化）：记录了企业从过去某一时刻到当前各个阶段的信息，可对发展历程和未来趋势做定量分析和预测。

        Data Extraction：数据清洗。
        ETL：数据抽取、转换、加载。
        OLAP：联机分析处理。
        OLTP：联机事务处理。
二十二、数据库设计过程
    1、需求分析：主要是分析用户需求
        需求
        （1）当前和未来应用的数据要求
        （2）数据处理要求
        产出
        （1）数据流图
        （2）数据字典
        （3）需求说明书
    2、概念结构设计：主要是为了画E-R图
        需求
        （1）当前和未来应用的数据要求
        （2）数据处理要求
        （3）需求分析结果
        产出
        （1）E-R模型
    3、逻辑结构设计：主要是为了设计数据库的表
        需求
        （1）转换规则
        （2）规范化理论
        （3）数据处理要求
        （4）DBMS特性
        （5）概念结构设计结果
        产出
        （1）关系模式（关系模型）
    4、物理设计：主要是为了选择合适的存储结构（顺序结构、索引结构、哈希结构）、存储方法（机械硬盘、固态硬盘）、存储路径（顺序访问、索引访问、直接访问），设计用户视图（建立视图虚表，另外视图在数据字典中保存的是视图定义），设计数据库的访问权限以及数据备份、数据容灾。
        需求
        （1）硬件、操作系统特性
        （2）数据处理要求
        （3）DBMS特性
        （4）逻辑结构设计结果
        产出
        （1）聚簇索引
二十三、概念设计阶段概述
    1、概念设计过程
        （1）需求分析
        （2）抽象数据
        （3）设计局部E-R模型
        （4）合并局部E-R模型，消除冲突
        （5）重构优化，消除冗余
        （6）逻辑设计

        集成的方法：
        （1）多个局部E-R模型一次集成。
        （2）逐步集成，用累加的方式一次集成两个局部ER。

        集成产生的冲突以及解决办法：（针对同一对象，比如都是学生，或者都是部门）
        （1）属性冲突：包括属性域冲突和属性取值冲突。
        （2）命名冲突：包括同名异义和异名同义。
        （3）结构冲突：包括同义对象在不同应用中具有不同的抽象，以及同一实体在不同局部ER图中所包含的属性个数和属性排列次序不完全相同。
    2、E-R模型（实体关系模型/图）
        （1）属性：
            用椭圆形表示，属性比如学生号。

            ① 简单属性：简单属性是原子的，不可以再分的，比如国内的姓名。
            ② 复合属性：复合属性可以细分为更小的部分，比如国外的姓名，他们会把姓和名拆开。
            ③ 单值属性：定义的属性对于一个特定的实体都只有单独的一个值，比如联系方式，记录一个联系方式。
            ④ 多值属性：定义的属性在某些特定情况下，一个属性可能对应一组值，比如联系方式，记录多个联系方式。
            ⑤ NULL属性：无意义，或者不知道。
            ⑥ 派生属性：可以从其他属性得来，比如从身份证号可以推算出性别，年龄等等。
        （2）关系：
            用菱形表示，关系比如1对1，1对n，n对n。

            ① 两个不同实体之间的关系：
                1对1：一个班级拥有一个班长。
                1对n：一个班级拥有多个学生。
                m对n：多个学生可以选修多个课程。
            ② 两个以上不同实体之间的关系（三元关系）：
                以三元关系中的一个实体为中心，假设另外两个实体都只有一个实例，若中心实体只有一个实例能与另外两个实体进行关联，则中心实体的连通数为“1”；若中心实体有多余一个实例能与另外两个实体实例进行关联（二者中只要有一个满足即可），则中心实体的连通数为“多”。
            ③ 同一个实体内的二元关系：
                比如球队，球队分为主队和客队，球队和球队是比赛关系。
            ④ 弱实体关系：
                该关系是指某实体是否存在对于另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提，这些实体称为弱实体，如家属与职工对于公司的关系，没有职工自然就没有家属，以及附件与邮件的关系，没有邮件自然就没有附件。弱实体关系使用双重叠的菱形表示，弱实体使用双重叠的矩形表示。
            ⑤ 特殊化关系：
                某些实体一方面具有一些共性，另一方面还具有各自的特性，一个实体可以按照某些特性分为几个子实体。比如员工和经理的关系，经理是员工的子实体。特殊化关系使用一个圆圈表示，子实体使用一个矩形在左右两边各加一条竖线表示。
            ⑥ 聚集关系：
                一个关系作为另一个关系的一端。比如房屋和租客有租赁关系，将这个关系看成一个实体可以视为租房合同，它还与租房经理有签约关系。

            1对n的情况下，外键建在“多”的实体表上；m对n的情况下，需要额外建立一个关系中间表，该表与原实体表应满足m对1，n对1的设计。
        （3）实体：
            用矩形表示，实体比如学生。
二十四、逻辑结构设计概述
    1、关系模式相关概念
        （1）关系模式：在二维表中的行定义，即对关系的描述称为关系模式。一般表示为关系名（属性1，属性2，......,属性n），如教师的关系模型可以表示为教师（教师号，姓名，性别，年龄，职称，所在系）。
        （2）关系：关系实质上就是一张表，一个关系对应着一个二维表，二维表名就是关系名。
        （3）数据模型：
            ① 层次模型：树
            ② 网状模型：图
            ③ 关系模式（模型）：二维表
            ④ 面向对象模型：以对象为单位组织数据模型
        （4）数据模型三要素：
            ① 数据结构：比如关系模式中划分的哪些属性（可以使用DDL数据定义语言来修改）
            ② 数据操作：针对数据有哪些操作方式（可以使用DML数据操作语言来修改）
            ③ 数据的约束条件：针对数据有哪些约束条件
        （5）相关概念：
            ① 目或度：关系模式中属性的个数
            ② 候选码（候选键）：唯一标识元组（元组tuple是关系数据库中的基本概念，关系是一张表，表中的每行，即数据库中的每条记录，就是一个元组，每列就是一个属性），且无冗余的属性集合，可以有一个，可以有多个，可以是单个属性，可以是多个属性的集合。
            ③ 主码（主键）：从候选码中任选一个，一般选择有一定逻辑意义的。
            ④ 主属性与非主属性：组成候选码的属性就是主属性，其余就是非主属性。
            ⑤ 外码（外键）：与本关系有联系的其他关系的主码。
            ⑥ 全码（ALL-Key）：关系的所有属性是这个关系的候选码。（就是所有属性全是候选码）
        （6）关系的三种类型
            ① 基本关系：就是数据库的表，存在数据库中，是实表。
            ② 查询表：使用sql查询的结果表，就是查询表，是虚表。
            ③ 视图表：对基本关系抽取一部分对外展示，就是视图表，是虚表。
        （7）完整性约束
            ① 实体完整性约束：主键一定是唯一的，主键一定非空。
            ② 参照完整性约束：外键要么是其他关系的主键，要么是空的。
            ③ 用户自定义完整性约束：用check来进行自定义的条件约束。
            ④ 触发器：它可以完成一些复杂的完整性约束条件的设定，可以对元组或者属性添加监听，一旦发生变化，就可以随之更新一些内容。
    2、E-R模型转关系模式 
        一个实体必须转换为一个关系模式。
        联系转关系模式：（建立独立关系指的就是建立一张关系中间表）
            1对1：
                合并实体：并入任意一端主键及联系自身的属性，主键保持不变。
                建立独立关系：并入两端主键及联系自身的属性，主键可以是任何一端的主键。
            1对n：
                合并实体：少的一端合并到多的一端，并入少的一端主键及联系自身的属性，主键保持不变。
                建立独立关系：并入两端主键及联系自身的属性，主键为多的一端的主键。
            m对n：
                建立独立关系：并入两端主键及联系自身的属性，主键为两端主键的组合键。
二十五、关系代数
    1、并交差运算：关系的属性必须一致，对两张表进行并集、交集、差集运算。并集和交集不解释，差集需要确认主体，比如S1差集运算S2，就是把存在于S1里面的，同时也存在于S2里面的去除，剩余留下来的S1的内容。

    2、笛卡尔积：两个参与笛卡尔积的关系，可以是相同的属性，也可以是不同的属性。如S1×S2（笛卡尔积），将S1的每一个元组都和S2的每一个元组合并成一个元组（排列组合，元组数是二者元组数乘积），属性进行合并（属性列数是二者属性列数之和），如果合并后的结果存在属性相同的情况，就需要在属性前面加上表名，如S1.属性，S2.属性进行区分。注意，在进行笛卡尔积之前，尽可能的对两张表先进行选择，元组越少那么参与笛卡尔积的元组就越少，效率就越高；另外要尽可能的满足小表驱动大表的理论，也就是要选择元组少的表作为笛卡尔积左面的表。

    3、投影：投影用“大写”的π表示，投影的对象是一个表（关系），投影是垂直方向，对属性列进行条件筛选，如果是1,2,3，就是保留1,2,3属性列。

    4、选择：选择用“小写”的σ表示，选择的对象是一个表（关系），选择是水平方向，对元组进行条件筛选，如果是1=2，就是保留属性列1=属性列2的元组，大于小于符号同理，多个条件用^符号连接。

    5、自然连接：自然连接用两个对顶的三角形表示，进行自然连接的两个表（关系），属性列是二者之和减去重复列；对于元组，同名的属性列中，只保留属性进行交集处理后的元组。注意，自然连接的结果等价于两个表先进行笛卡尔积，然后进行选择（选择同名属性列值相等），然后进行投影（投影同名属性列其中的一个）的结果。性能方面，自然连接优于笛卡尔积。

    SQL语句中：
        select对应的是投影
        from多个表对应的是多个表的笛卡尔积
        where对应的是选择
二十六、规范化理论概述
    1、规范化理论基本概念
        （1）函数依赖：设R(U)是属性U上的一个关系模式，X和Y是U的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X->Y。X为决定因素，Y为被决定因素。函数依赖本质存在于属性之间的。
        如果有：
            关系模式：R(A，B，C)
            函数依赖：(AB->C，A->C)
        此时可以说属性C部分依赖于AB。
        如果有：
            关系模式：R(A，B，C)
            函数依赖：(A->B，B->C)
        此时可以说属性C传递依赖（冗余依赖）于属性A。
        （2）Amstrong公理体系
            （下面的字母代表的是属性集合）
            ① 自反律：在属性集合U中有一个属性集合X，在属性集合X中有一个属性集合Y，则X->Y成立。
            ② 增广律：在整个属性集合U中，如果X->Y，此时增加一个属性集合U中的属性集合Z，则XZ->YZ成立。
            ③ 传递律：若X->Y，Y->Z，则X->Z。
            根据以上三条推理规则可以得到下面三条推理规则：
            ① 合并规则：若X->Y，X->Z，则X->YZ。（根据增广律和传递律得出）
            ② 伪传递规则：若X->Y，WY->Z，则XW->Z。（其实就是小依赖关系能带入到大的依赖关系中，根据增广律和传递律得出）
            ③ 分解规则：若X->Y，此时有一个在Y属性集合中的Z，则X->Z。（根据自反律和传递律得出）
        （3）候选键
            唯一标识元组，且无冗余的属性集合（可以有一个，可以有多个）就是候选键。从候选键中任选一个就是主键。与本关系有联系的其他关系的主键就是外键。
            图示法画函数依赖图求候选键：
                ① 将关系的函数依赖关系用有向图进行表示。
                ② 找出入度为0的属性集合，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有节点，则该属性集合即为关系模式的候选键。
                ③ 若入度为0的属性集合不能遍历图中所有节点，则需要尝试性的将一些中间节点（即有入度，也有出度的节点）并入入度为0的属性集合中，直至该集合能够遍历所有节点，则该集合就是候选键。
            主属性与非主属性：组成候选键的属性就是主属性，其他的就是非主属性。
    2、范式判断
        （1）为什么要有规范化？
            假如没有满足到第三范式，都可能会导致以下问题：
                ① 数据冗余：有大量的重复数据记录，占用空间。
                ② 修改异常：修改数据不一致。
                ③ 插入异常：假如插入的数据主键恰好为空，就会插不进去。
                ④ 删除异常：假如删了一个信息，可能会导致同一记录里面的其他不想被删除的数据同样被删除。
        （2）第一范式：属性不可分割。假如有个属性“高级职称人数”，但是高级职称既有“教授”，又有“副教授”，那么该属性就可以分割成“教授人数”，“副教授人数”，很显然不满足属性不可分割，不满足第一范式。
        （3）第二范式：满足第一范式，且不存在部分依赖（不存在非主属性对候选键的部分依赖）。假如有三个属性，学号，课程号，学分，根据指定的条件，其中学号和课程号可以决定学分，但是又因为仅凭一个课程号就可以决定学分，学号是多余的，所以这就属于学分部分依赖学号、课程号这个组合键，那么就不满足不存在部分依赖，不满足第二范式。
        （4）第三范式：满足第二范式，且不存在传递依赖（不存在非主属性对候选键的传递依赖）。假如有三个属性，学号，系号，系名，根据指定的条件，其中学号可以决定系号，但是系号又可以决定系名，那么就出现了学号->系号->系名，系名传递依赖于学号，不满足第三范式。
        （5）BC范式：满足第三范式，关系模式中，所有函数依赖的左边（决定因素），全部都是候选键，那么就满足了BC范式，只要有一个函数依赖左边不是候选键，就不满足BC范式（不存在主属性对候选键的部分、传递依赖）。假如有三个属性，学生，老师，课程，根据指定的条件，其中学生和老师可以决定课程，老师可以决定课程，候选键是学生老师组合键，学生课程组合键这两个，因为老师决定课程这个函数依赖不满足老师属于候选键之一，所以该关系模式不满足BC范式（学生老师组合键可以决定主属性老师，但是单独一个主属性老师就可以决定主属性老师，所以属于主属性老师部分依赖于学生老师组合键）。

        注：
            （1）一般满足到第三范式时，规范化程度就已经足够了。
            （2）调整第二、第三范式的本质上就是拆分表。第二范式的联合主键中，被部分依赖的主键作为外键，依赖的属性拆分到第二张表中；第三范式的传递依赖中，中间的属性作为外键，尾部的属性拆分到第二张表中。
            （3）候选键是单属性至少满足第二范式，没有非主属性至少满足第三范式。
    3、模式分解
        模式分解的作用就是为了使得关系模式能够达到第三范式。调整第二、第三范式的本质上就是拆分表。如果不满足第二范式，第二范式的联合主键中，被部分依赖的主键作为外键，依赖的属性拆分到第二张表中；如果不满足第三范式，第三范式的传递依赖中，中间的属性作为外键，尾部的属性拆分到第二张表中。

        分解过后，可以进行如下两种情况判断。

        （1）判断是否是“保持函数依赖分解”
            判断是否是“保持函数依赖分解”，就是判断：
                第一步：拆分过后的函数依赖，通过合并后等不等于拆分前的函数依赖。
                第二步：拆分过后的函数依赖两端的“决定因素”和“被决定因素”属性，通过合并后等不等于拆分过后的，与该函数依赖相对应的关系模式。
            比如有：
                关系模式A：成绩（学号，姓名，课程号，课程名，分数）
                函数依赖A：{学号->姓名，课程号->课程名，（学号，课程号）->学分}
            分解为：
                关系模式B：成绩（学号，课程号，分数）
                函数依赖B：{（学号，课程号）->学分}

                关系模式C：学生（学号，姓名）
                函数依赖C：{学号->姓名}

                关系模式D：课程（课程号，课程名）
                函数依赖D：{课程号->课程名}
            函数依赖B，C，D通过合并后，等于函数依赖A，所以这个分解属于“保持函数依赖分解”。

            注意：能够被推导出来的函数依赖，即便在分解后没有保留，我们也可以说它逻辑蕴含，依然是保持函数依赖的（也就是冗余函数依赖不需要考虑）。
        （2）判断是否是“无损连接分解”
            判断是否是“无损连接分解”，就是判断：
                拆分过后的关系模式能够“还原”到拆分前的关系模式，本质上就是通过候选键根据函数依赖进行合并关系模式，合并之后的关系模式等于拆分之前的关系模式。
            比如有：
                关系模式A：成绩（学号，姓名，课程号，课程名，分数）
                函数依赖A：{学号->姓名，课程号->课程名，（学号，课程号）->学分}
            分解为：
                关系模式B：成绩（学号，课程号，分数）
                函数依赖B：{（学号，课程号）->学分}

                关系模式C：学生（学号，姓名）
                函数依赖C：{学号->姓名}

                关系模式D：课程（课程号，课程名）
                函数依赖D：{课程号->课程名}
            关系模式B，C，D通过函数依赖B，C，D进行合并（相同的去重）。关系模式C通过函数依赖C，把学号和姓名带入到关系模式B后就为成绩（学号，姓名，课程号，分数），同理带入关系模式D，结果为成绩（学号，姓名，课程号，课程名，分数），与关系模式A一致，所以这个分解属于“无损连接分解”。
二十七、SQL语言
    数据查询语言（DQL）：select
    数据定义语言（DDL）：create、drop、alter
    数据操纵语言（DML）：insert、update、delete
    数据控制语言（DCL）：grant、revoke

    1、普通查询
        不解释，做题注意笛卡尔积和自然连接即可。
        例题：
            关系R（A,B,C,D,E）
            关系S（B,C,F,G）
        那么与表达式π2,4,6,7(σ2<7(R 自然连接 S))等价的SQL语句为：

        因为R与S进行自然连接，自然连接的特点就是相同属性列进行合并，属性值仅保留两个关系取交集的内容。

        这里因为R.B，R.C和S.B，S.C是相同属性列，所以where条件必须有R.B = S.B and R.C = S.C的条件；

        选择操作要求第二列小于第七列，此时第二列为R.B，第七列为S.G，所以where条件必须有R.B < S.G；

        然后对属性列进行投影即可，重名属性列带上关系，所以最终的SQL语句如下：
        
        selet R.B,D,F,G from R,S where R.B = S.B and R.C = S.C and R.B < S.G;
    2、分组查询
        不解释，做题注意三元关系的几对几判断即可。
    3、权限控制
        grant授权，revoke撤销授权
        with grant option 级联授权
        restrict 非级联撤销授权
        cascade 级联撤销授权
二十八、并发控制
    1、事务的特性
        ​原子性（Atomicity）：原子性指的就是事务里面执行的增删改操作是一个原子操作，要么全部成功，要么全部失败。

        ​一致性（Consistency）：一致性指的是事务操作前和事务操作后数据必须是正确的。

        ​隔离性（Isolation）：隔离性指的是多个事务同时操作数据库的时候有相应的隔离级别，可以限制事务与事务之间数据的影响。

        持久性（Durability）：持久性指的是事务做完操作之后，数据就永久保存了，不会因为一些原因比如数据库崩溃导致数据丢失。
    2、并发问题
        脏读，不可重复度，幻读

        读未提交：读未提交会引起“脏读”问题。脏读就是指一个事务插入数据后，还没有提交事务的情况下，其他的事务就可以读到该数据，这就是脏读问题。

        读已提交：读已提交解决了脏读的问题，但是没有解决“不可重复读”的问题。不可重复读指的是一个事务读两次相同的数据，发现两次读到的数据是不一致的。因为中间有其他的事务修改这个数据。

        可重复读：为了避免不可重复读的问题，我们可以把事务的隔离级别提高到可重复读的级别。可重复读解决了不可重复读的问题，但是有“幻读”的问题，幻读是指一个事务读到数据库里面没有一条数据，在他插入该数据的时候突然发现数据库里面已经有这个数据了。

        序列化读：数据库提供了序列化读的隔离级别，可以解决幻读问题。隔离级别越高，那么数据库的性能就会越低。
    3、封锁协议
        共享锁/S锁/读锁：若事务对数据加上了S锁，其他事物只能对该数据再加S锁，不能再加X锁。

        排他锁/独占锁/X锁/写锁：若事务对数据加上了X锁，其他事物不能再对该数据加任何锁。

        两段锁协议：两段锁协议指的是每个事务的执行可以分为两个阶段，生长阶段（加锁阶段）和衰退阶段（解锁阶段），
            加锁阶段：在该阶段可以进行加锁操作，在对任何数据进行读操作之前都要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行
            解锁阶段：当事务释放了一个锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

        死锁可以通过破坏死锁条件，以及预防死锁的办法来解决，也可以用银行家算法来避免死锁，具体参考“十四、死锁资源数计算”。
二十九、算法
    1、算法效率
        （1）时间复杂度：
            指程序运行从开始到结束所要的时间。因为在很多情况下要准确的计算时间复杂度是非常困难的，因此引入了渐进时间复杂度在数量上估算一个算法的基本操作总数。比如一个程序的实际执行时间为T(n)=3n³+2n²+n，求其渐进时间复杂度，当n趋近于无穷大时，2n²+n的影响很小，时间主要由最高阶，也就是3n³来决定，同时也要忽视掉最高阶的常量值，即T(n)的渐进时间复杂度是O(n³)。

            常见时间复杂度的大小对比：
            O(1) < O(log₂n) < O(n) < O(nlog₂n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)
            
            O(1)级:
                ① 单个语句。
                ② 整个程序只有顺序执行的语句，没有循环语句或者复杂函数调用。
            O(log₂n)级：
                ① 二叉树结构。比如二分查找。
            O(n)级：
                ① 单层循环。
            O(nlog₂n)级：
                ① 二叉树结构，同时这个二叉树结构要执行n次。比如堆排序。
            O(n²)级：
                ① 双层循环。
            O(n³)级：
                ① 三层循环。
            O(2ⁿ)级别：
                ① 比如最长子序列，动态规划自顶向下。
            O(n!)级别：
                ① 比如排列组合问题。
        （2）空间复杂度：
            指程序在运行过程中临时占用存储空间的大小，只考虑运行过程中为局部变量分配的存储空间的大小。
    2、查找算法
        （1）顺序查找：将待查找的元素与数组元素进行挨个比较，如果存在返回成功，否则返回失败，时间复杂度为O(n)。
        （2）二分查找：首先要确保数组（注意是数组，非链表）元素是有序的，假如数组元素从小到大排列，将待查找的元素与数组中间的元素进行对比，如果相等返回成功，如果小于则对左半边的数组进行同样的操作，如果大于则对右半边的数组进行同样的操作，直到找到待查找的元素，或者数组全部处理完成，时间复杂度为O(log₂n)。
        （3）哈希查找：对待查找的元素，将该元素的关键字按照指定的哈希函数（或者散列函数）进行哈希运算，映射到一段有限的、地址连续的存储空间中，将元素的内容存入该存储空间，这个存储空间称为哈希表（或者散列表），在查找时只需要将待查找的元素的关键字代入哈希函数就可以直接查询到对应的存储空间内容，如果内容一致返回成功，时间复杂度为O(1)。（哈希冲突可以使用线性探测法、拉链法来解决）
    3、排序算法
        什么是稳定排序与不稳定排序？
            对于一组元素，如果经过排序后相同元素的相对位置不发生变化，就叫做稳定排序，反之就叫做不稳定排序。比如1，2，1，3，5，如果排序之后第一个1在第二个1的后面（相对位置发生了变化），就是不稳定排序。
        
        如何确定是稳定排序还是不稳定排序？
            在排序过程中，如果是相邻的元素进行比较，一定是稳定排序，如果是不相邻的元素进行比较，可能是不稳定排序。

        （1）插入排序（稳定，时间复杂度O(n²)，空间复杂度O(1)）
            待排序元素数组中，对第n个元素进行排序，此时第1，2...n-1个元素已经有序，将第n个元素依次与第1，2...n-1个元素进行比较，插入到合适的位置。插入排序是稳定排序，双层循环结构，时间复杂度为O(n²)。适用于基本有序的情况，此时时间复杂度接近线性，即O(n)。空间复杂度O(1)。
        （2）冒泡排序（稳定，时间复杂度O(n²)，空间复杂度O(1)）
            待排序元素数组通过相邻元素之间的比较和交换，将较大的元素（或者较小的元素）逐渐从底部移向顶部，由于整个排序过程元素就像水底下的气泡一样逐渐向上冒，因此称为冒泡排序。冒泡排序是稳定排序，双层循环结构，时间复杂度为O(n²)。空间复杂度为O(1)。
        （3）选择排序（不稳定，时间复杂度O(n²)，空间复杂度O(1)）
            首先在待排序元素数组中找出最小的元素，把它与数组的第一个位置交换，然后在其余的元素数组中找出最小的元素，把它与数组的第二个位置交换，直到所有的元素全部排序完成为止。选择排序是不稳定排序，双层循环结构，时间复杂度为O(n²)。空间复杂度为O(1)。
        （4）希尔排序（不稳定，时间复杂度O(n¹·³)，空间复杂度O(1)）-插入排序改进
            用到了分组的思想来提高插入排序的效率。首先要确认一个用来分组的“增量”，这个增量一般都是用奇数的，然后通过增量来进行分组，比如待排序数组3，2，4，5，6，增量取5/2取奇数为3，那么3，5为一组，2，6为一组，4单独为一组，对每一组分别进行插入排序，然后对增量再进行划分3/2取奇数为1，进行同样的操作，增量为1时停止再划分，也就是所有的元素都放在同一组中进行插入排序为止。希尔排序是不稳定排序，据统计分析时间复杂度为O(n¹·³)。空间复杂度为O(1)。
        （5）快速排序（不稳定，时间复杂度O(nlog₂n)，空间复杂度O(log₂n)）-冒泡排序改进
            用到了分治的思想来提高冒泡排序的效率。核心思想是将原问题分解成若干个规模更小但结构与原问题相似的子问题，通过递归地解决这些子问题，然后再将这些子问题的解组合成原问题的解，比如待排序数组6，7，5，3，4，按照从小到大排序，首先可以选择中间元素5充作基准元素，将两边的元素依次轮替着与基准元素比较，最终要让左边的元素都小于5，右边的元素都大于5，经过第一轮排序变为4，3，5，6，7，然后再分别对基准元素5的左右两边部分进行同样的操作（选基准，左右比较基准），直到分无可分。快速排序是不稳定排序，因为每完成一次排序都会将原数组分解成两个子数组（理想情况下），所以很显然这是一个“自顶向下”的二叉树结构，这个二叉递归树的高度为log₂n，又因为每一层都要完成差不多对整个数组的遍历，这个遍历的时间为O(n)，所以合计时间复杂度为O(nlog₂n)，注意如果在最坏的情况下，也就是原数组基本有序的情况下，如果基准元素选择第一个或者最后一个，那么每次几乎都不能将原数组分解成两个子数组，那么快速排序就会退化成了冒泡排序，时间复杂度为O(n²)，此时可以选择中间元素充当基准元素，时间复杂度依然是O(nlog₂n)。因为快速排序用到的递归树高度是log₂n，而递归树又存储在栈中，实际上需要的空间就是这个栈空间，空间复杂度为O(log₂n)。
        （6）堆排序（不稳定，时间复杂度O(nlog₂n)，空间复杂度O(1)）-选择排序改进
            小顶堆：如果任何一个节点即小于它的左孩子又小于它的右孩子，它就为小顶堆，顶部节点为最小。
            大顶堆：如果任何一个节点即大于它的左孩子又大于它的右孩子，它就为大顶堆，顶部节点为最大。

            用到了堆结构来提高选择排序的效率。首先将待排序元素数组调整为堆结构，然后得到堆顶元素，再将剩下的元素重新调整成一个新的堆结构，再次得到堆顶元素，直到所有的元素均输出为止，此时输出的元素序列就是一个有序序列。堆排序是不稳定排序，时间复杂度为O(nlog₂n)。对于大量元素来说，堆排序的效率很高。空间复杂度为O(1)。

            顶堆的构造过程：
                比如对数据列7,10,13,15,4,20,19,8构建大顶堆。
                ① 先按照元素顺序构建一个二叉树，得到二叉树如下：
                                    7
                            10              13
                        15      4       20      19
                    8
                ② 然后从n/2地方（最后一个父节点）也就是7/2向下取整为3，也就是从15开始，让最后一个“(a)父节点以及它之前所有的父节点都要满足父节点大于左右孩子节点，如果父节点小于孩子节点，就交换二者，如果两个孩子节点都比父节点大，那么就选择一个最大的与父节点交换”。“(b)注意一旦发生交换的新的孩子节点要重新进行向下的，以它为父节点的大顶堆的比较，直到没有孩子节点”。那么交换步骤如下：
                    经过(a)得到如下结果，
                                    20
                            15              7
                        10      4       13      19
                    8
                    此时发现直到第一个父节点交换完成后，右孩子节点又比它的左右孩子小了，那么进行(b)处理，得到如下结果，
                                    20
                            15              19
                        10      4       13      7
                    8
                至此就完成了初始大顶堆的构建，得到数据列为20,15,19,10,4,13,7,8。
        （7）归并排序（稳定，时间复杂度O(nlog₂n)，空间复杂度O(n)）
            归并排序也用到了分治的思想，快速排序是通过选择一个基准元素来将数组分割成两部分，而归并排序是直接将数组从中间分开，然后再对两个分开的数组继续从各自的中间分开，直到分无可分，使得最小的数组局部有序，然后依次将分开的数组按照层级一层一层的合并，在合并的过程中，通过双指针分别遍历将要合并的两个数组进行比较，使得合并后的数组局部有序，重复操作直到所有层级全部合并完毕为整个数组。归并排序是稳定排序（虽然跨区域比较，但是双指针都是从最小的开始比较，如果二者相等不去交换它们，就是稳定排序），因为每完成一次排序都会使得待排序的数组长度乘2，直到等于原数组长度，所以很显然这是一个“自底向上”的二叉树结构，这个二叉递归树的高度为log₂n，又因为每一层都要完成差不多对整个数组的遍历，这个遍历的时间为O(n)，所以合计时间复杂度为O(nlog₂n)，即便在基本有序的情况下时间复杂度依然为O(nlog₂n)。因为需要一个额外的一维数组来存储这些合并后的数据，所以空间复杂度为O(n)。
        （8）基数排序（稳定，时间复杂度O(d(n+k))，空间复杂度O(n)）
            基数排序是一种借助多关键字排序思想对单关键字进行排序的方法。比如待排序数组135，242，192，93，345，11，24，19，按照从小到大排序，首先对个位进行排序（排序直到数组里面元素的最高位），得到11，242，192，93，24，135，345，19，然后再对十位进行排序，得到11，19，24，135，242，345，192，93，最后再对百位进行排序，得到11，19，24，93，135，192，242，345。基数排序是稳定排序，时间复杂度为O(d(n+k))，其中n是待排序数组元素个数，d是最大数字的位数，k是数字的基数（十进制中，基数是10）。

        排序方法使用场景总结：
            如果待排序的数组元素个数较少，可以采用插入排序和选择排序，由于插入排序的元素移动操作较选择排序多，因此当元素本身的信息量大时用选择排序方法较好。

            如果待排序的数组元素基本有序，更适合用插入排序或冒泡排序。

            如果待排序的数组元素个数很多，并且排序关键字位数较少时，更适合使用基数排序。

            如果待排序的数组元素个数很多，则应采用时间复杂度为O(nlog₂n)的排序方法，比如快速排序、堆排序、归并排序。
                （1）快速排序目前被认为是内部排序中最好的方法，当待排序的关键字随机分布时，快速排序的平均运行时间最短。
                （2）堆排序只需要一个辅助空间，并且不会出现快速排序退化成冒泡排序的情况。
                （3）快速排序和堆排序都是不稳定排序，若要求稳定排序，可以选择归并排序。
    4、图、树算法
        （1）图存储结构
            ① 领接表
                一个一维数组和多个链表组成，一维数组存储的是每个以顶点作为头节点的链表，每个链表存储的则是与该顶点有关系的顶点所在的数组的下标，比如A与B相连，一维数组的0位置存放A的链表，1位置存放B的链表，A链表的头节点后面追加一个节点，存储的数值内容是1，然后指向下一个节点的指针为null；B链表的头节点后面追加一个节点，存储的数值内容是0，然后指向下一个节点的指针为null。倘若存储的图是一个有路径长度的图（带权图），节点要顺带记录下路径的长度。邻接表多用于稀疏图。
            ② 邻接矩阵
                一个二维数组，横列和纵列代表每一个顶点与所有顶点之间的关系，可以是两顶点之间的长度（带权图），也可以用来表示两顶点之间是否相连（无权图）。左斜对角线代表的是每一个顶点与自己的关系，在有路径长度的图中存储的是最大值，在无路径长度的图中存储的是零。邻接矩阵多用于稠密图。
        （2）深度优先搜索
            深度优先搜索（DFS）是一种用于遍历图、树数据结构的算法。通常通过递归实现（栈用来实现递归）。是一种优先走到底、无路可走再回头的遍历方式。
        （3）广度优先搜索
            广度优先搜索（BFS）是一种用于遍历图、树数据结构的算法。通常通过队列实现。是一种由近及远、一层一层的遍历方式，从某个节点出发，始终优先访问距离最近的节点，直到与该节点最近的节点全部遍历完成才会紧接着下一层的节点按照同样的方式进行遍历。
        （4）普利姆算法（顶点选择策略的最小生成树算法）
            普里姆算法采用贪心策略，每次从已选择的顶点集合中选择一个与未选择顶点集合中距离最近的顶点，并将其加入到已选择的顶点集合中，直到所有顶点都被选择为止。在实际应用中，普里姆算法常用于解决诸如修路问题、电路设计等最小成本问题。例如，在修路问题中，我们可以将每个村庄看作一个顶点，村庄之间的距离看作边的权值，然后使用普里姆算法找到连接所有村庄且总距离最小的路线。
        （5）克鲁斯卡尔算法（边选择策略的最小生成树算法）
            与普里姆算法不同，克鲁斯卡尔算法采用边选择的策略，每次选择权值最小的边，并判断这条边是否会与已选择的边构成回路。如果不构成回路，则将其加入到最小生成树中；如果构成回路，则选择下一条权值最小的边。重复这个过程直到所有顶点都被包含在最小生成树中。克鲁斯卡尔算法在实际应用中也具有广泛的应用，如电路设计、网络布局等。例如，在电路设计中，我们可以将每个电子元件看作一个顶点，元件之间的连接看作边的权值，然后使用克鲁斯卡尔算法找到连接所有元件且总电阻最小的电路。
        （6）迪杰斯特拉算法（单源最短路径算法）
            迪杰斯特拉算法是一种用于解决有权图中最短路径问题的算法。它从起始点开始，采用贪心策略，每次选择距离起始点最近的未访问顶点，并更新该顶点到其他顶点的最短路径。重复这个过程直到所有顶点都被访问过为止。迪杰斯特拉算法在实际应用中常用于路由选择、网络优化等问题。例如，在网络中，我们可以将每个节点看作一个顶点，节点之间的距离看作边的权值，然后使用迪杰斯特拉算法找到从一个节点到另一个节点的最短路径。这对于网络路由选择、流量控制等场景非常有用。
        （7）弗洛伊德算法（多源最短路径算法）
            暂不描述
        （8）树的前序遍历、中序遍历、后序遍历、层序遍历
            ① 前序遍历：属于深度优先搜索。先访问根节点，再访问左节点，最后访问右节点。注意按照此规则递归每一个子树直到最底层，因为父树的左节点很有可能是一个子树的根节点。
            ② 中序遍历：属于深度优先搜索。先访问左节点，再访问根节点，最后访问右节点。注意按照此规则递归每一个子树直到最底层，因为父树的左节点很有可能是一个子树的根节点。
            ③ 后序遍历：属于深度优先搜索。先访问左节点，再访问右节点，最后访问根节点。注意按照此规则递归每一个子树直到最底层，因为父树的左节点很有可能是一个子树的根节点。
            ④ 层序遍历：属于广度优先搜索。一层一层的遍历树中的每一个节点。
    5、算法策略
        （1）分治法
            把一个问题拆分成多个规模更小，但是相同的子问题，一般可以用递归解决。
        
            经典问题：斐波那契数列、归并排序、快速排序、矩阵乘法、二分查找、大整数乘法、汉诺塔。
        （2）贪心法
            求解局部最优，但整体不一定最优，每步都有明确的、既定的策略。

            经典问题：背包问题、多机调度、找零钱问题、最小生成树问题（普利姆算法、克鲁斯卡尔算法）。
        （3）动态规划法
            用于求最优解，使用“最优子结构”和递归式（带记忆的递归调用），划分子问题使用数组存储子问题结果，利用查询子问题结果构造最终问题结果。一般自顶向下时间复杂度为O(2ⁿ)（一定会用到递归结构）；自底向上时间复杂度为O(n^a)效率更高（一定会用数组来存储中间结果）。

            经典问题：斐波那契数列、矩阵乘法、背包问题、LCS最长公共子序列。
        （4）回溯法
            系统地搜索一个问题的所有解或任一解。回溯法一般可以通过减枝的操作来提升效率。

            经典问题：N皇后问题、迷宫问题、背包问题。
    6、递归
        递归分为自顶向下递归和自底向上递归：
        （1）自顶向下递归
            是从问题的最高层次开始，逐步分解问题到最低层次，然后逐层向上解决问题。这种方法通常使用递归函数来实现，函数会调用自身来解决问题的一部分，直到达到基本情况。例如，在计算斐波那契数列时，自顶向下递归会从F(n)开始，逐步分解到F(1)和F(0)，然后逐层向上计算结果‌。
        （2）自底向上递归
            是从最低层次开始，逐步向上解决问题。这种方法通常使用循环和迭代来实现，而不是递归调用。例如，在计算斐波那契数列时，自底向上递归会先计算F(1)和F(0)，然后逐步向上计算到F(n)
    7、二叉树分类
        （1）完满二叉树：叶子结点都在同一层，除叶子节点以外其他节点都是满的，不存在空节点，深度为k，有2^k-1个节点。
        （2）完美（完全）二叉树：除最后一层外，其他层的节点都是满的，并且最后一层的节点都集中在左侧，完全二叉树不一定是满二叉树，但满二叉树一定是完全二叉树。
        （3）平衡二叉树：左右子树的高度差不超过1，这种树的插入、搜索和删除操作的平均时间复杂度为O(logN)。
三十、面向对象基础
    （1）对象
        万物皆对象，将自然存在的实体认定为对象，也就是自然存在的“名词”认定为对象。一个对象往往会有两个特征：
            静态特征：称为属性/状态/数据/变量
            动态特征：称为方法/函数/功能
        
        面向对象程序设计语言为面向对象实现。

        访问修饰符：
        + public：所有位置的元素都可以访问它。
        # protected：只有同一个包下的元素，或者子类（无论在哪个包）中的元素才可以访问它。
            default：只有同一个包下的元素才可以访问它。
        - private：只有同一个类下的元素才可以访问它。

        外界对对象内属性或方法的访问称为消息。
    （2）类
        类是抽象的概念，对象是具体化的概念，通过对类进行实例化可以得到对象。比如对猫类进行实例化，得到一个对象白猫。

        实体类（数据类）：现实世界真实存在的实体，有大量属性。
        接口类（功能类/边界类）：为用户提供系统交互的方式，有大量方法。
        控制类：描述业务逻辑，用来控制业务流，充当实体类和接口类之间的协调者。
    （3）接口
        接口是一种特殊的类，它只有方法定义，没有实现，主要是充当父类让对象类来实现。
    （4）封装
        将属性和方法封装在对象里，隐藏对象的内部细节，仅对外提供接口。 
    （5）继承
        让一个对象获取另一个对象的属性和方法，在不重写现有代码的基础上实现代码的重用。

        二义性：一个子类能否继承两个父类。
        在JAVA中是不支持二义性的（继承是单继承的，实现是多实现的），但是C++是支持二义性的。
    （6）多态
        不同的对象对相同的消息作出不同响应，也就是调用相同类型对象的方法有不同的行为。
    （7）重写和重载
        重写发生在类之间（2个类），子类继承父类，重写父类的方法。方法的名字、参数类型、参数个数与父类方法完全一致，重写用到了动态绑定机制，属于运行时多态。
        重载发生在类之内（1个类），两个方法在一个类中，方法的名字相同，方法中参数类型或者参数个数不同，重载用到了静态绑定机制，属于编译时多态。
    （8）面向对象开发流程
       ① 面向对象分析
            ① 认定对象（名词）
            ② 组织对象（抽象成类）
            ③ 描述对象间的相互作用
            ④ 确定基于对象的操作
       ② 面向对象设计
            ① 识别类及对象
            ② 定义属性
            ③ 定义服务
            ④ 识别关系
            ⑤ 识别包
       ③ 面向对象程序设计
            ① 程序设计标准
            ② 选择一种OOPL（面向对象编程语言）
       ④ 面向对象测试
            ① 测试算法
            ② 测试类
            ③ 测试模块
            ④ 测试系统
    （9）面向对象的设计原则
        1. 开闭原则：
        ​	描述：程序应该对扩展开放，对修改关闭。在设计程序时应该可以在不修改原有程序的基础上能扩展其他功能。
        ​	实现方法：
        ​		（1）可以把不变的部分抽象成接口，这些接口可以应对未来的扩展；
        ​       （2）接口最小功能设计原则，根据这个原则原有的接口如果无法应对未来的扩展，不足的部分可以通过定义新的接口来实现；
        ​		（3）模块间的调用通过接口进行，这样即使实现层发生变化也无需修改调用方的代码。
        2. 里氏替换原则：子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。子类可以扩展父类功能，但是不能改变父类原有的功能，子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
        3. 单一职能原则：只能让一个类、接口、方法有且仅有一个职责，它们需要改变，改变的理由永远只有一个，如果存在多个改变它们的理由就需要重新设计。
        4. 接口隔离原则：一个类对另外一个类的依赖是建立在一个最小的接口之上的。客户端程序不应该依赖它不需要的接口方法。简单的说就是不要创建臃肿庞大的接口，要把接口尽量细化，方法尽量少。
        5. 依赖倒转原则：高层模块不应该依赖于底层模块，两者都应该依赖接口。抽象不能依赖于具体，具体应该依赖于抽象。简单理解就是面向接口编程。
        6. 迪米特原则：又称最少知道原则。一个对象应当对其他对象有尽可能少的了解，不和陌生人说话，降低各个对象之间的耦合，提高系统的可维护性。
        7. 组合重用原则：尽量使用对象组合，而不是继承来达到复用的目的。即在一个新的对象里面使用一些已有的对象使之成为新对象的一部分。继承关系是强耦合，组合关系是低耦合。
    （10）面向对象测试
        对面向对象软件的测试可以分为下列4个层次进行：
            ① 算法层：测试类中定义的每个方法，基本上相当于传统软件测试中的单元测试。
            ② 类层：测试封装在同一个类中的所有方法与属性之间的相互作用。在面向对象软件中类是基本模块，因此可以认为这是面向对象测试中所特有的模块测试。
            ③ 模板层：测试一组协同工作的类之间的相互作用，大体上相当于传统软件测试中的集成测试，但是也有面向对象软件的特点，例如对象之间通过发送消息相互作用。
            ④ 系统层：把各个子系统组装成完整的面向对象软件系统，在组装过程中同时进行测试。
三十一、UML图
    UML：统一标识语言。
    
    UML图可以分为
    （1）静态的结构图
        ① 类图：通常对系统词汇、简单协作、逻辑数据库模式进行建模，描述一组类、接口、协作和它们之间的关系。
            类图中的关系：
                （a）关联关系：一条实线连接。类A有个getB方法得到B对象，类B有个getA方法得到A对象，就称为关联关系。
                （b）依赖关系：一条虚线实心箭头连接。类A有个方法需要用到类B，xxx(B b)，就称为类A依赖类B。
                （c）泛化关系：一条实线空心箭头连接。特殊/一般关系，存在于父子类之间。
                （d）聚合关系：一条实线空心菱形连接。“整体”与“部分”生命周期不同。
                （e）组合关系：一条实线实心菱形连接。“整体”与“部分”生命周期相同。
                （f）实现关系：一条虚线空心箭头连接。接口与类之间的关系，存在于父子类之间。
        ② 对象图：描述某一刻一组对象以及它们之间的关系。
            在图上与类图十分相似，区别就是看第一栏有没有“:”，有就是对象图，并且冒号的前面是对象名，后面是类名。
            提供给别人的接口叫做供接口，是圆形。
            需要别人提供的接口叫做需接口，是半圆。
        ③ 包图：用于把模型本身组织称层次结构的通用机制，不能执行，展现由模型本身分解而成的组织单元以及其间的依赖关系。包可以拥有其他元素，可以是类、接口、构件、节点、协作、用例和图，甚至是嵌套的其他包。一个元素只能被一个包所拥有，拥有关系的包形成了一个命名空间，一个包内元素不能重名。
            在图上有点类似文件和文件夹的样子。
        ④ 组合结构图：不考。
        ⑤ 构件图/组件图/模块图：一组组件之间的组织和依赖，专注于系统的静态实现视图。主要描述各模块之间的依赖关系。
        ⑥ 部署图：运行处理结点以及构件的配置，给出体系结构的静态实施视图，该图是唯一与硬件有关的图。
        ⑦ 制品图：不考。
    （2）动态的行为图
        ① 用例图：描述一组用例（椭圆）、参与者（小人，具体为人、硬件或其他可以扮演的角色）以及它们之间的关系。
            用例图中的关系：
                （a）包含关系：虚线箭头，并且上面写有<<include>>。大功能指向小功能，大功能包含小功能。
                （b）扩展关系：虚线箭头，并且上面写有<<extend>>。小功能指向大功能，小功能扩展大功能。
                （c）泛化关系：实线空心箭头。多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。
            用例图建模流程：
                （a）识别参与者（必须）
                （b）合并需求获得用例（必须）
                （c）细化用例描述（必须）
                （d）调整用例模型（可选）
        ② 序列图/顺序图：场景的图像化表示，以时间顺序组织的对象间的交互活动。
            实线箭头：调用消息
            虚线箭头：返回消息
            以（）为标准，文字后面有括号就是调用消息，没有括号就是返回消息。
        ③ 通信图：强调收发消息的对象之间的组织结构。与序列图没有本质上的区别，只不过序列图强调的是时序，通信图强调的是对象之间的关系。
            实线箭头：调用消息
            虚线箭头：返回消息
            以（）为标准，文字后面有括号就是调用消息，没有括号就是返回消息。
        ④ 定时图：不考。
        ⑤ 状态图：展现了一个状态机，由状态、转换、事件和活动组成。主要用于对反应型对象建模。
            状态图由以下五部分构成：
                （a）一般状态，起始状态，终止状态
                    起始状态是实心圆。
                    终止状态是空心圆套一个实心圆。
                    一般状态是一个弧角的椭圆矩形。
                    一个状态有以下几个部分：
                        状态名name
                        进入/退出动作entry/exit action
                        内部转移internal transition
                        子状态substate
                        延迟事件deferred event
                （b）事件
                    状态和状态之间转移就会有事件。
                    常见的事件类型：
                        信号事件：对象之间发送信号和接受信号实现通信，如鼠标。
                        调用事件：一个对象调用另一个对象的操作，如方法调用。
                        变换事件：when后面接布尔表达式，如when(A>100)。
                        事件事件：到达某一时间或经过某一个时间段，用when和after表示。
                （c）监护条件
                    事件发生时的条件判断叫做监护条件。
                （d）动作
                    条件成立后会发生动作。
                （e）转移（又称为转换）
                    从A状态到B状态的整个过程叫做转移。
                    格式：事件(参数)[条件]/动作
                （f）组合状态
                    顺序子状态：组合状态内部的多个子状态是串行执行。
                    并发子状态：组合状态内部的多个子状态是并发执行的，某个时刻可以同时达到多个子状态。
                    注意：组合状态内部即便没有执行到终止状态，如果此时有一个该组合状态的后继状态的事件发生，那么会直接进入到这个后继状态。
        ⑥ 活动图：专注于系统的动态视图，一个活动到另一个活动的流程。更多的是从业务的层面上描述一个功能是如何实现的。
            起点是实心圆。
            终点是空心圆套一个实心圆。
            活动与活动之间的流转，是一个实线箭头，叫做流。
            活动又称为动作，是一个弧角的椭圆矩形。
            有并发的业务逻辑就有一个粗黑线名为并发分岔，同时下面还会有一个粗黑线名为并发汇合。
            活动图中的菱形是条件判断，叫做分支。
            条件判断中的具体的条件叫做监护表达式。
        ⑦ 交互概览图：不考，
三十二、信息安全
    信息安全的五个基本要素
        （1）机密性：确保信息不暴露给未授权的实体或进程，
        （2）完整性：只有得到允许的人才能修改数据，并且能够判断出数据是否已被篡改。
        （3）可用性：得到授权的实体在需要时可访问数据，即攻击者不能占用所有的资源而阻碍授权者的工作。
        （4）可控性：可以控制授权范围内的信息流向及行为方式。
        （5）可审查性：对出现的信息安全问题提供调查的依据和手段。
    加密技术与认证技术
        （1）对称加密与非对称加密
            对称加密：又称为非公开密钥加密，两边的密钥是一样的。
                发送方用密钥和对称加密算法进行加密，接收方用密钥和对称加密算法进行解密。
                特点：
                    （a）密钥要用安全信道进行传递，密钥分发困难（其实可以使用非对称加密来对对称加密的密钥进行加密）。
                    （b）加密强度不高，加密效率高。
                常见的对称加密算法：
                    分组加密（明文分组加密）：
                        DES、AES、3DES(三重DES)、IDEA。
                    流加密（明文整体加密）：
                        RC-5。
                口诀：
                    3S+I5。
            非对称加密：又称为公开密钥加密，两边的密钥是不一样的。
                发送方和接收方都有一个公钥和私钥，公钥是公开的，私钥是自己独有的。发送方用接收方的公钥和非对称加密算法进行加密，接收方用自己的私钥和非对称加密算法进行解密。注意，不一定非得是公钥加密私钥解密，也可以用私钥加密公钥解密，这里具体的应用可以参考下面的（2）。
                特点：
                    （a）密钥不需要专门的安全信道进行传递。
                    （b）加密强度高，加密效率低。
                常见的非对称加密算法：
                    RSA、DSA、ECC。
                口诀：
                    AACC。
        （2）数字签名与信息摘要
            发送方用信息摘要算法获取到明文的信息摘要（对明文信息的浓缩，算法不要求可逆），然后用自己的私钥和非对称加密算法对信息摘要进行加密（这个过程就叫做数字签名），接收方用发送方的公钥和非对称加密算法对信息摘要进行解密，然后接收方再用信息摘要算法获取到明文的信息摘要，通过对比就可以确定这个信息一定是指定的发送方发送过来的，并且没有被任何人伪造或者篡改。
            作用：
                （a）接收方可以验证信息来源的真实性。
                （b）发送者无法否认发送过的信息。
                （c）除了发送者以外，其他人无法伪造或者篡改信息。
            常见的信息摘要算法：
                MD5、SHA等，市场上广泛使用的MD5、SHA算法的散列值分别为128位和160位，由于SHA通常采用的密钥长度较长，因此安全性高于MD5。
        （3）数字证书
            数字签名与信息摘要只是确认了这个信息确实是指定的发送方发送的，但是无法确认发送方的身份是否合法。
            
            假如A要确认B的身份是否合法，B需要提前向CA（证书授权机构）申请证书，证书包含三个内容，B的公钥，B的名称，CA签名（CA用自己的私钥和非对称加密算法对某个东西加密出来的东西）。
            
            在通信时，A首先从B处下载B的数字证书，然后向CA获取CA的公钥，然后用CA的公钥和非对称加密算法解密CA签名，如果能解密出来说明这个数字证书确实是CA颁发的，那么B的身份就是合法的，开始正常通信。A首先从数字证书中获取到B的公钥，然后用B的公钥和非对称加密算法对A的“对称加密的密钥”进行加密（这里就是对称加密中的用安全信道交换密钥），然后B就可以用自己的私钥和非对称加密算法进行解密获得“对称加密的密钥”，之后A和B的通信采用对称加密即可，这样效率高。
    常见的网络安全协议：
        （1）PGP：优良保密协议，邮件和文件的混合加密协议。
        （2）SSL：安全套接字协议，工作在传输层至应用层。
        （3）HTTPS：HTTP+SSL，默认端口443，HTTPS是用“会话密钥（证书验证通过，使用对方的公钥和非对称加密算法生成会话密钥）”和“对称加密（对方获取到会话密钥后，使用自己的私钥和非对称加密算法来解密获取到一个密钥，这个密钥用于对称加密消息）”方式来加密HTTP消息的。
        （4）TLS：传输层安全协议。
        （5）SET：安全电子交易协议，用于电子商务和身份认证，普遍的说法是将其归为应用层。
        （6）IPSEsC：互联网安全协议，对IP包加密。
    传输协议：
        （1）TCP：可靠的，面向连接的。
            POP3：110端口，电子邮件协议。
            FTP：20/21端口，文件传输协议。
            HTTP：80端口，超文本传输协议。
            Telnet：23端口，远程登录协议。
            SMTP：25端口，电子邮件协议。
            IMAP：143端口，交互邮件访问协议。
        （2）UDP：不可靠，无连接的。
            DHCP：67端口，动态主机配置协议。
            TFTP：69端口，简单文件传输协议。
            SNMP：161端口，简单网络管理协议。
            DNS：53端口，域名系统。
    网络攻击：
        被动攻击（不会立即造成损失）：
            （1）监听：非法窃取信息中的内容。
            （2）业务流分析：通过对系统进行长期监听，利用统计分析方法对诸如通信频度、通信的信息流向、通信总量的变化等参数进行研究，从而发现有价值的信息和规律。
            （3）非法登录：有些资料将这种方式归为被动攻击。
        主动攻击（会立即造成损失）：
            （1）假冒身份：通过欺骗系统实现非法用户冒充合法用户，或者小权限用户冒充大权限用户。
            （2）抵赖：这是一种来自用户的攻击，否认自己曾经发布过某些信息或者伪造一份对方来信等。
            （3）旁路控制：利用系统的安全缺陷获得非授权的权限。
            （4）重放攻击：对某次合法的通信出于非法的目的而被重新发送。
            （5）拒绝服务攻击：对系统进行不断的请求，占用系统的资源，使得系统无法响应其他合法的请求。
            （6）SQL注入攻击：欺骗系统执行恶意的SQL命令，首要目的是获取数据库的访问权限。（可以对用户输入做关键字过滤或者转义、Web应用防火墙（防SQL注入、防网页篡改等）、定期扫描系统漏洞并及时修复都可以有效防御SQL注入攻击）
    计算机病毒、木马：
        病毒：主要目的是破坏，影响计算机使用并且能够自我复制的程序。病毒具有隐蔽性、传染性、潜伏性、触发性和破坏性等特点。
            （1）引导型病毒：植入在引导盘，开机会自启。
            （2）文件型病毒：常见exe文件。
            （3）宏病毒：办公软件的宏命令执行破坏性的指令。
            （4）网络型病毒：病毒邮件等。
            （5）混合型病毒：混合上述的病毒。
        木马：主要目的是控制，是一种后门程序，常被黑客用作控制远程计算机的工具。
三十三、网络安全控制技术
    （1）信息存储安全
        （a）信息使用安全
        （b）系统安全监控
        （c）计算机病毒防治
        （d）数据的加密
        （e）防治非法攻击
    （2）用户识别技术
        （a）口令认证
        （b）生物识别认证
        （c）U盾认证
        （d）多因子认证
    （3）访问控制技术
        控制不同用户对信息紫苑得访问权限。
    （4）访问控制列表ACL
        对数据包进行过滤，允许其通过或丢弃，访问控制列表广泛地应用在路由器和三层交换机，借助于访问控制列表可以有效地控制用户对网络的访问，从而最大程度地保障网络安全，ACL也可以结合防火墙使用。
    （5）网络安全漏洞扫描技术
        可以发现高危风险和安全漏洞，单纯的漏洞扫描技术是不包括修复功能的。
    （6）IDS入侵检测技术、IPS入侵防御技术技术
        IDS入侵检测技术：本地检测软件监督计算机操作，将操作行为与模式库可疑行为记录进行模式匹配，如果匹配成功则报警。
        IPS入侵防御技术：本地检测软件监督计算机操作，将操作行为与模式库可疑行为记录进行模式匹配，如果匹配成功则进行主动防御，例如进行断开连接、主动向攻击者发送ICMP不可达数据包（ICMP不可达相当于是针对入侵者断网了）、记录日志和动态生成防御规则等。
    （7）防火墙技术
        防火墙是建立在内外网络边界上的过滤封锁机制，它认为内部网络是安全和可信赖的，而外部网络是不安全和不可信赖的。
        防火墙一般具有以下几个功能：
            （a）访问控制功能（ACL）
            （b）内容控制功能
            （c）全面的日志功能
            （d）集中管理功能
            （e）自身的安全和可用性
            （f）流量控制
            （g）网络地址转换（NAT）
                SNAT：源IP地址转换，SNAT在数据包从内部网络发送到外部网络时工作，当一个内部主机发送一个数据包到外部网络时，防火墙会查看其NAT表，看看是否有任何与该内部主机的源IP地址匹配的条目。如果有，防火墙就会将数据包的源IP地址替换为NAT表中的公网IP地址（把内网地址换成公网地址）。然后，防火墙会将修改后的数据包发送到外部网络的相应主机。
                DNAT：目的IP地址转换，DNAT在数据包从外部网络发送到内部网络时工作，当一个外部主机发送一个数据包到内部网络时，防火墙会查看其NAT表，看看是否有任何与该数据包的目标IP地址匹配的条目。如果有，防火墙就会将数据包的目标IP地址替换为NAT表中的内部IP地址（把公网地址换成内网地址）。然后，防火墙会将修改后的数据包发送到内部网络的相应主机。
                源IP地址:表示该条信息来源于哪个机器。
                目的IP地址:表示该条信息去往哪个机器。
            （h）VPN
        防火墙分类：
            （a）网络级：路由器实现。
                ① 包过滤
                ② 状态监测
            （b）应用级
                ① 双穴主机：也就是多加一个堡垒机。
                ② 屏蔽主机：在堡垒机前面再加一层路由器。
                ③ 屏蔽子网：设置内网无法被外界访问到。
            层次越高，工作效率越低，安全性越高；层次越低，工作效率越高，安全性越低。
三十四、安全防范体系
    （1）物理环境的完全性。
    （2）操作系统的安全性。
    （3）网络的安全性。
    （4）应用的安全性。
    （5）管理的安全性。
三十五、McCabe方法
    McCabe方法就是根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度。

    流图（程序图）：
        实质上是“退化了的”程序流程图，秒回程序的控制流程，不表现对数据的具体操作以及分支或循环的具体条件，主要是为了突出程序的控制流。
    
    环形复杂度计算方法：
        为了应付考试，这里只列举一种简单好用的计算方法。
        环形复杂度V(G) = 判定结点数（判定结点就是分支结点，也就是菱形的、“分叉出去”的结点） + 1

   环形复杂度的用途主要是对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。实践表明，模块规模以V(G)<=10为宜。
三十六、设计模式
    面向对象程序设计中才存在如下的设计模式，设计模式中非常关键的是它大量的运用到“多态”的思想才使得代码更灵活方便。

    类结构和对象结构的区别是，类结构描述的是如何通过继承提供更有用的功能，而对象结构描述的是通过使用对象的组合或将对象包含在别的对象里面以获得更有用的结构。

    1、创建型五种（创建型主要是为了创建对象）
        类结构：
        （1）factory method 工厂方法模式：工厂是将对象的创建抽象出了一个工厂类，然后实现具体的工厂类中的对象的创建方法，通过指定的工厂类来创建指定的对象。与抽象工厂相比，工厂更侧重的是一个指定的工厂类只能创建单一的对象。

        对象结构：
        （1）abstract factory 抽象工厂模式：抽象工厂与工厂十分类似，但是抽象工厂更注重的是创建一系列相关的对象，也就是一个指定的工厂类能够创建多个对象。与工厂模式相比，抽象工厂是将多个相关的对象的创建抽象出了一个工厂类，然后实现具体的工厂类中的多个对象的创建方法，通过指定的工厂类来创建指定的多个对象。

        （2）prototype 原型模式：原型模式是用原型实例指定创建对象的类型，并且通过拷贝原型来创建新对象。在原型模式中，客户端可以直接从原型对象通过克隆来创建新对象，而无需了解对象创建的细节。这种通过复制原有的对象而不是通过实例化来创建对象的方式在需要快速生成大量相似对象时非常有用，尤其是当对象创建成本较高时。原型模式是通过让待拷贝对象实现Cloneable接口并且实现clone方法（注意这里的clone方法不是重写Object的clone方法，是为了泛用性而抽象出来的抽象原型父类中定义的clone方法，由具体的原型类来实现这个clone方法），在使用时通过调用clone方法来返回新的对象（注意选择合适的拷贝方法，比如深拷贝或者浅拷贝）。

        （3）singleton 单例模式：单例是在整个应用程序环境中只会存在一份对象，分为饿汉式单例模式和懒汉式单例模式，饿汉式是在类初始化的时候将所有的单例对象全部生成，而懒汉式是在使用的时候才会生成对象。
        
        （4）builder 建造者模式：建造者是将一个复杂对象的创建分解为多个简单的对象一步一步构建而成，它注重方法的调用顺序，此外它还将变与不变相分离，即产品的组成部分是不变的，但每一个组成部分是可以灵活选择的。
    2、结构型七种（结构型主要是为了组装现有的类，设计类之间的交互方式）
        类/对象结构：
        （1）adapter 适配器模式：适配器是将一个类的接口转换成客户希望的另一个接口，它使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，比如写一个适配器类，然后实现一个目标接口，同时持有一个需要适配的适配者类对象。通过适配器类的中间转换实现了适配器类与目标接口的兼容。

        对象结构：
        （1）bridge 桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。这主要是解决一个类存在两个或多个变化维度的情况，对这两个或者多个变化维度进行独立的扩展。假如一个类有两个变化维度，比如在两种类型的操作系统上打印两种类型的图片，这里的操作系统和图片类型就是两个变化维度，考虑到将来可能会有第三种操作系统、第三种图片类型所以要预留这种变化，那么就可以抽象出一个类“操作系统类”、一个接口“打印方式接口”，在“操作系统类”里面调用“打印方式接口”的打印方法，这样就可以预留出这种变化，如果出现了第三种操作系统、第三种打印方式，只需要让第三种操作系统去继承操作系统类，让第三种打印方式去实现打印方式接口，这样就可以在不动原有的代码情况下正常的调用新增的功能。两种以上的情况同理。

        （2）composite 组合模式：将有层级关系的多个对象组合成树型结构以表示“整体-部分”的层次结构，使得用户可以以统一的方式处理单个对象或组合对象。假如有一个文件夹，里面既有文件夹又有视频文件、音乐文件、文档文件，要求打印里面的文件名，这里就很符合组合模式的树形结构，倘若不采用组合模式，那么只能分别设置四种文件类型列表以及对应的文件类型，一个一个的将文件存入列表然后循环打印。如果想忽视单个对象和组合对象的区别，统一的处理这四种文件，只需要将这四种文件类型抽象出来，划分成一个容器组件和一个叶子组件，文件夹作为容器组件，其余三种文件类型作为叶子组件，在容器组件里面实现循环遍历打印方法，那么就可以忽视掉这四种文件类型的区别，统一用抽象类型来接收，不管是容器组件（组合对象）还是叶子组件（单个对象）全部存入到容器组件的抽象类型列表里，通过调用容器组件的循环遍历打印方法进行打印，简化了客户端代码。

        （3）decorator 装饰器模式：装饰器是在不改变原始类的情况下，对原始类进行增强，比如在原始类的方法执行前后进行一些操作，它有点类似代理模式，但是代理模式做的额外处理跟原始方法没有关系，比如权限控制日志打印，而装饰器则是对原始方法进行扩展添加额外的功能。

        （4）facade 外观(门面)模式：外观模式引入了一个新的外观类(Facade)，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。

        （5）flyweight 享元模式：主要用于减少创建对象的数量以降低内存占用和提升性能，它会尝试重用已有的同类对象，当没有找到匹配的对象时，才会创建新的对象。享元个人认为这种翻译的很不好，就跟鲁棒性翻译一样，按照这种翻译来说享元就是共享元对象，元对象就是想要减少创建数量的那个最初的对象，也就是“共享想要减少创建数量的那个最初的对象”。具体操作中其实非常类似工厂模式和单例模式的混合使用，工厂模式每次都会创建一个新的对象返回，享元模式就是根据传入的参数先查看一个Map集合中是否存在这个对象，如果存在就直接返回，如果不存在就new出这个对象返回，然后把这个对象和传入的参数保存在Map集合中。

        （6）proxy 代理模式：代理是对原始类进行增强，比如在原始类的方法执行前后进行一些操作。它分为静态代理和动态代理，静态代理是在编译期间就已经生成代理类，而动态代理是在运行期间生成代理类，静态代理的缺点是每个代理类只能代理一个原始类，而动态代理可以代理多个原始类。
    3、行为型十一种（行为型主要是关注对象之间的执行逻辑）
        类结构：
        （1）template method 模板方法模式：模板是在一个抽象类中定义了执行它的方法模板，它的子类可以按照需要重写方法进行实现，但具体的使用将以抽象类中定义的方式进行。

        （2）interpreter 解释器模式：用于定义一种语言的语法表示，并实现一个解释器根据语法表示来解释该语言中的句子。主要是将语言抽象成一个表达式类，并且可以划分成终端表达式子类，比如1+2*2中的1，自己就符合语义，和非终端表达式子类，比如1+2*2中的+、*，单独一个+、*号无意义，必须连接其他语法，在给定的例子中，终端表达式主要定义数值，非终端表达式主要定义操作，终端表达式作为非终端表达式的参数，然后通过非终端表达式的互相组合来表达原文语法，解释出对应的结果。

        对象结构：
        （1）chain of responsibility 责任链模式：责任链是将一个请求按照一定的顺序交给多个处理器来进行处理，每个处理器都可以对其进行处理或者传递给链上的下一个处理器。

        （2）command 命令模式：将一个请求（方法调用）封装为一个对象，并传递给调用对象，调用对象把该命令传递给处理该命令的合适的对象，让该对象执行命令，从而可以对请求进行参数化，并且能够支持请求的排队执行、记录日志、撤销和重做等操作。实际上就是将所有的命令抽象出一个命令类，然后不同的命令实现具体的命令实现类，将所有的命令实现类全部保存在调用对象的属性里，调用对象就可以根据不同的情况调用不同的命令实现类。

        （3）iterator 迭代器模式：迭代器模式提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即不暴露其内部的结构。如果我们的集合元素是用不同的方式实现的，有数组，还有Java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。实际上就是将各个对象以及获取各自的遍历迭代器抽象出一个父类，各自实现具体的创建迭代器的方法（实现Iterator接口的hasNext和next方法），那么就可以直接根据不同实现类调用获取遍历迭代器的方法直接获取到对应的迭代器进行遍历。

        （4）mediator 中介者模式：又被称为调停者模式，核心思想是通过引入一个中介对象来封装一系列对象之间的交互。这种设计模式使得各个对象不需要显式地相互引用。主要是将各个对象类抽象出一个父类，分别实现具体交互逻辑，然后将这些对象保存在中介者对象的一个List中，在中介者对象的调用方法中按照需要遍历List来组装相互之间的交互逻辑。

        （5）memento 备忘录模式：备忘录模式允许在不破坏对象封装性的前提下，获取并保存一个对象的内部状态，以便在需要时可以恢复到之前的状态。这种设计模式通常用于实现撤销和重做功能。这里实际上就是新加了一个状态备份类，在保存时，将待备份的对象赋值给状态备份类的属性，然后把这个状态备份类保存在一个List里面，那么就可以根据下标获取到指定的状态备份类，就可以将保存的内容再赋值回去。

        （6）observer 观察者模式：观察者又称为发布订阅模式，是在对象之间定义一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。核心是将观察者的对象全部保存在一个List里，当被观察者发生改变时，由被观察者来主动的遍历这个List去挨个调用观察者的代码。

        （7）state 状态模式：状态模式允许对象在其内部状态发生变化时改变其行为。这种设计模式可以消除大量的条件语句，并将每个状态的行为封装到单独的类中。实际上就是将对象的所有行为抽象出了一个状态类，针对不同的状态实现不同的状态实现类，在每一个状态实现类中实现当前状态下该对象的所有的行为逻辑，这样只要赋予了对应的状态实现类，那么调用行为逻辑是不需要进行状态条件判断的，除非状态实现类中预先写好的行为逻辑是错的。通过状态模式可以实现状态机（有限状态自动机），运行中的状态模式就是状态机。顺带一提，游戏中的AI可以通过行为树和状态机来实现，行为树决策AI的行为逻辑，状态机用来支撑AI的状态变化。

        （8）strategy 策略模式：策略是将行为抽象出了一个行为类，然后实现具体的行为类中的行为方法，通过指定的行为类来执行指定的行为逻辑。

        （9）visitor 访问者模式：访问者模式用于在不改变现有对象结构的情况下，实现对对象中各个元素的访问操作。实际上就是给这个被访问对象设置一个专门的方法，在这个方法里面调用访问者对象的方法，并且把被访问对象当做参数传入，那么访问者的具体实现类就可以拿到被访问者对象然后实现访问逻辑。
三十七、其他知识点
    1、软件著作权人可以全部或者部分转让其软件著作权，许可他人行使其软件著作权，并有权获得报酬。
    2、为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬（也就是软件仅用于学习和交流，不用于商用）。
    3、当软件完成之日起，这个软件就已经有软件著作权了。软件著作权属于自然人的，该自然人死亡后，在软件著作权的保护期内（50年内），继承人可以继承除署名权以外的其他各种权利，另外需要注意的是，即便过了软件著作权的保护期，署名权依然无法被继承！
    4、委托开发软件的著作权归属如果没有书面合同或合同中未明确约定，则该软件的著作权由受托人享有。
    5、软件著作权种的翻译权是将原软件由一种自然语言文字转换成另一种自然语言文字的权利。
    6、软件项目的活动图中的关键路径指的是，软件项目从开始到结束，花费时间最长的那条路径（一天也不能耽误的那条路径）。
    7、甲乙丙三者分别就相同内容的发明创造，先后向专利管理部门提出申请，先申请者可以获得专利申请权，同时申请则协商。
    8、知识产权中，软件著作权的署名权、修改权，以及普通著作权作品的署名权、修改权、保护作品完整权，都可以永久保护。其他著作权的保护期限是作者终身及其死后50年。特殊的保护期限中，商标权可以续注延长，商业秘密权保密期限不确定。
    9、由n个成员组成的开发团队，计算有多少条沟通路径，也就是对这n个成员进行排列组合，首先沟通路径是一对一的，也就是从n个里面任意选两个，并且不要求方向，那么就是求一个C(n,2)，也就是(n(n-1))/2。如果要求方向，那么就是求一个A(n,2)，也就是n(n-1)。如果有C(n,3)，A(n,3)同理。
    10、软件设计师软考中的正规式，说的就是正则表达式（这种描述跟鲁棒性、设计模式中的享元模式一个尿性，跟谭浩强学的吧）。
    11、在敏捷开发中，
        （1）极限编程(XP)：由4个价值观，5个原则，12个最佳实践组成。是一种轻量级、高效、低风险、柔性、可预测、科学的软件开发方式。
        （2）水晶法(Crystal)：对每一个不同的项目都需要一套不同的策略、约定、方法论。
        （3）并列争球法(Scrum)：使用迭代的方法把一段短的时间的迭代称为一个冲刺，并按照需求优先级来实现产品。
        （4）自适应软件开发(ASD)：有6个基本原则，即便需求不断地变化，也能满足随时调整开发内容。
    12、耦合
        耦合是对模块之间的独立性的度量。
        （1）无直接耦合：两个模块之间没有任何关系。
        （2）数据耦合：两个模块之间有调用关系，传递的是简单的数据值。
        （3）标记耦合：两个模块之间有调用关系，传递的是数据结构。
        （4）控制耦合：两个模块之间有调用关系，传递的是控制变量，该变量将决定接收模块中的执行逻辑。
        （5）外部耦合：两个模块通过软件以外的环境联系，比如IO。
        （6）公共耦合：两个模块通过公共数据环境进行联系。
        （7）内容耦合：一个模块直接使用了另一个模块的内部数据，而没有通过另外一个模块专门对外暴露的使用接口。
        从上往下耦合度越来越高，模块独立性越来越低。
    13、用栈运算表达式时，需要先把中缀表达式转换为后缀表达式，比如a+b，a-b，a*b，a/b都属于中缀表达式，转换为后缀表达式就是ab+，ab-，ab*，ab/，然后遇到数值就进栈，遇到符号就出栈两个数值，先出栈的放在符号右边，后出栈的放到符号左边，将结果再次入栈依次往下进行。
        比如利用栈对算术表达式10*(40-30/5)+20求值，运算过程如下：
            （1）首先将该中缀表达式转换为后缀表达式为 10 40 30 5 / - * 20 +；
            （2）依次将数值入栈，此时10，40，30，5会依次入栈；
            （3）之后碰见了符号/，那么出栈两个数值，先出栈的放在右边，后出栈的放在左边，那么就是30/5，得到结果为6，再次入栈，此时栈中的数据为10，40，6；
            （4）接着又碰见了符号-，同理操作后此时栈中的数据为10，34；
            （5）接着又碰见了符号*，同理操作后此时栈中的数据为340；
            （6）然后碰见了数值20，将20入栈，此时栈中的数据为340，20；
            （7）最后又碰见了符号+，同理操作后此时栈中的数据为360；
        这就是通过栈来运算表达式的过程，需要存放操作数的栈的容量至少为4。
    14、哈夫曼编码
        哈夫曼编码是一种用于数据压缩的编码方法，它通过给不同出现频率的数据分配不同长度的编码，使得高频率的数据具有较短的编码，而低频率的数据具有较长的编码，从而达到压缩数据的目的。哈夫曼编码的核心思想是构建一个哈夫曼树，哈夫曼树是一个二叉树，左节点记为0，右节点记为1，按照对应的节点进行编码。
        
        假设要对“we will r u”进行压缩，
            （1）首先统计每个字符的频率，“w”出现2次，“e”出现1次，“i”出现1次，“l”出现2次，“r”出现1次，“u”出现1次；
            （2）将每个字符创建成一个单独的树节点；
            （3）从所有的字符中选择两个频率最低的节点合并为一个新的节点，其频率为两个节点的频率之和，将这个新节点归入到节点列表中；
            （4）重复步骤（3）直到节点列表中只剩下一个节点，也就是哈夫曼树的根节点；
            （5）对哈夫曼树进行遍历，左节点记为0，右节点记为1，标记每个字符对应的编码；
            （6）使用编码替换原来的字符，得到哈夫曼编码；
        另外哈夫曼树是一个满二叉树，也就是树中只会有“出度为0的节点”和“出度为2的节点”，并且“出度为2的节点”比“出度为0的节点”少1个，所有的节点只会有奇数个。
    15、森林转换二叉树
        （1）每一棵树的兄弟节点连上一条线；
        （2）每一棵树的每一层的每一个节点，去掉除了与第一个子节点以外，其他节点的连线；
        （3）根据左孩子，右兄弟的规定，将所有树进行合并，两两通过其中一棵树的根节点作为另一棵树的右子节点，结合成一棵新树，依次合并到只剩下最后一棵树；
    16、统一过程模型（UP模型）的四个阶段
        （1）起始阶段：起始阶段专注于项目的初创活动。产生的主要工作产品有构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划（阶段及迭代）、业务模型以及一个或多个原型（需要时）。
        （2）精化阶段：精化阶段进行需求分析和架构演进。产生的主要工作产品有用例模型、补充需求（包括非功能需求）、分析模型、软件体系结构描述、可执行的软件体系结构原型、初步的设计模型、修订的风险列表、项目计划（包括迭代计划、调整的工作流、里程碑和技术工作产品）以及初始用户手册。
        （3）构建阶段：构建阶段关注系统的构建。产生实现模型，产生的主要工作产品有设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档（用户手册、安装手册和对于并发增量的描述）。
        （4）移交阶段：移交阶段关注于软件提交方面的工作。产生软件增量，产生的主要工作产品有提交的软件增量、β测试报告和综合用户反馈。
    17、汇编程序的功能是将汇编语言源程序翻译为相应的目标程序，汇编语言编写的程序是不能直接被计算机硬件执行的，汇编语言是低级程序设计语言，汇编语言与计算机硬件体系结构密切相关。
    18、白盒测试
        白盒测试关注的是程序内部的运行逻辑，而不是输入的合理性（黑盒测试），有以下原则：
        （1）程序模块中得到所有独立路径至少执行一次。
        （2）在所有的逻辑判断中，取“真”和取“假”的两种情况至少都能执行一次。
        （3）每个循环都应在边界条件和一般条件下各执行一次。
        （4）测试程序内部数据结构的有效性。

        白盒测试的六种方法：
        （1）语句覆盖
        （2）判定覆盖
        （3）条件覆盖
        （4）判定/条件覆盖
        （5）条件组合覆盖
        （6）路径覆盖
        从上往下错误发现能力越来越强。
    19、在项目开发过程中，项目估算的主要目的是为了评估项目所需的规模、类型和工作量，以便更好地规划资源和时间，成本通常是估算的结果之一，而不是进行估算的原因。
    20、基于构建的开发模型是利用预先包装的构件来构造应用系统，构件可以是组织内部开发的构件，也可以是商品化成品软件构件，基于构件的开发模型具有许多螺旋模型的特点，它本质上是演化模型，需要以迭代方式构建软件，其不同之处在于基于构件的开发模型采用预先打包的软件构件开发应用系统。比如Java编写后台服务器的QQ机器人，与QQ的交互用的就是打包好的构件GO-CQHTTP，而且也不要求必须用面向对象开发技术，GO就不是面向对象的。
    21、快速原型模型适用于系统规模不大也不复杂、用户需求不清、需求经常变化的情况。螺旋模型适用于系统规模大的情况。
    22、测试原则
        （1）应充分的注意到测试中的群集现象，也就是错误往往出想在某几个模块中。
        （2）设计测试用例时，应包括合理的输入条件和不合理的输入条件。
        （3）不应该由程序员测试自己编写的程序。
        （4）严格执行测试计划，避免测试的随意性。
    23、甘特图是一种进度管理工具，以日历为基准描述项目任务，能够清晰地描述每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性，但是它不能清晰地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分。
    24、PERT图是一个有向图，图中的箭头表示任务，它可以标上完成该任务所需的时间，图中的节点表示流入节点的任务的结束，并开始流出节点的任务，这里把节点称为事件，只有当流入该节点的所有任务都结束时，节点所表示的事件才出现，流出节点的任务才可以开始。PERT图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径。图中的松弛时间则反映了完成某些任务时可以推迟其开始时间或延长其所需完成的时间。但是PERT图不能反映任务之间的并行关系，以及不能看出目前项目的实际进度情况。
    25、X.509数字证书使用的密码算法是RSA，而国密SM2数字证书采用的公钥密码算法是ECC。
    26、如果是为了描述某一个功能根据信息的不同而采取不同的行为，这种时候用判定表（决策表）来描述该功能最为贴切，如果使用流程图的话会有非常多的菱形条件判断，看起来也是不直观的。
    27、关于风险管理要承认风险是客观存在的，不可能完全避免，比如地震、火灾、断网等，风险管理应该贯穿整个项目管理过程，风险计划本身可能会带来新的风险，比如为了管理一个大风险而会导致一个新的小风险这也是可以接受的。
    28、关于三层C/S结构中，三层分别是表示层，功能层，数据层，允许合理划分三层结构的功能，使之在逻辑上保持相对独立性，提高系统的可维护性和可扩展性，允许更灵活有效地选用相应的软硬件平台和系统（举一个例子，作为数据层存储数据的数据库运行在Linux上，而应用程序运行在Windows上），应用的各层可以并发开发，可以采用不同的开发语言，利用功能层有效地隔离表示层和数据层，便于严格的安全管理，例如数据权限控制等。
    29、故障类型
        （1）事物内部故障：事务内部故障有的可以通过事务程序本身发现然后执行回滚等操作，但有的是非预期的不能由事务程序处理，比如运算溢出、算术异常、空指针异常、并发事务发生死锁等等（JAVA的SpringBoot事务回滚并非是原始的事务处理，它是封装了一层逻辑，一旦捕获到任何异常都会进行处理）。
        （2）系统故障：通常为软故障，是指造成系统停止运行的任何事件，使得系统要重新启动，比如CPU故障、操作系统故障和突然停电等。
        （3）介质故障：通常为硬故障，比如磁盘损坏、磁头碰撞和瞬时强磁干扰。此类故障发生的几率小，但破坏性最大。
        （4）计算机病毒：这是一种人为的故障和破坏，是在计算机程序中插入的破坏，计算机功能或者数据可以繁殖和传播的一组计算机指令或程序代码。
    30、VLAN tag虚拟交换机标签在OSI参考模型的数据链路层（交换机在这个层）实现。
    31、IP地址长度为32位(IPV4)或128位(IPV6)，IP地址工作在网络层，MAC地址工作在数据链路层，IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商，IP地址不具有唯一性（因为可能会有不同的网络拓扑环境），MAC地址具有唯一性，但是要注意MAC地址可能会被篡改。
    32、对于上午题最后5个英文资料填空题，首先要明白一点的是，即便是全中文填词都不一定能写的对，因为很多词都能说的过去，区别就是参考原文的作者没这样写罢了，它不完全是正确性填词，更类似于原文复述，所以如果实在看不懂，建议全部选择B或者全部选择C。
    33、下午题的第一题数据流图要求补充缺失的数据流及其起点和终点可以从以下方面来考虑：
        （1）父图和子图要平衡，也就是父图和系统有数据流交互，那么在子图中也应该要体现出这些交互，如果缺失，就补充这些缺失。
        （2）加工（Process）既要有输入数据流，也要有输出数据流。
        （3）数据守恒，每一个功能描述在子图中是否做了相应的事情，如果做了就是守恒的，没有做的就需要补充。
    34、软件开发一般为定长时间，而软件维护是指软件从开始使用至消亡的过程，属于软件生命周期中最长的阶段，工作量、成本也是最大的，可以对软件代码、软件软硬件等多种内容进行修改。

查缺补漏：
    进制转换，原反补移范围
    段页存储
    面向对象设计原则
    UML图
    二十三种设计模式
    关系模式里的冗余，三个范式的内容，关系代数（选择、投影、自然连接）等等
    排序算法的时空复杂度
    最短路径算法


