一、数据的表示
    1、进制转换
        如果有一数为x^n，我们称x为基数，n为位权。
        （1）其他进制转换十进制（按权展开法）
            在按权展开时，小数点左起第一位为x^0，小数点右起第一位为x^-1。
            如二进制1011.11转为十进制，
                整数部分：1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11
                小数部分：1*(2^-1) + 1*(2^-2) = 0.75
                因此该数的十进制为11.75
        （2）十进制转换其他进制（短除法/除基取余法，短乘法/乘基取整法）
            如十进制11.75转为二进制，
                整数部分（短除法/除基取余法）：
                    11 / 2 = 5 余 1
                    5  / 2 = 2 余 1
                    2  / 2 = 1 余 0
                    1  / 2 = 0 余 1
                    则整数部分的二进制为，余数从下往上1011
                小数部分（短乘法/乘基取整法）：
                    0.75 * 2 = 1.5 取整 1
                    0.5  * 2 = 1   取整 1
                    则小数部分的二进制为，整数从上往下11
                因此该数的二进制为1011.11
                注意有时候小数是乘不尽的，此时只需要根据精度进行舍去即可，也就是说这些数是无法准确的用二进制进行表示的，然而计算机底层硬件的计算就是用二进制进行计算的，这也是为什么计算机中的浮点数计算会存在精度误差的问题（当然也有其他的问题，比如浮点数的对阶导致尾数移动从而精度丢失等）。
        （3）二进制与八进制、十六进制互相快速转换（三位一组，四位一组，不足补0，采用8421码快速计算）
            二进制：1010    
            八进制（三位一组）：001 010 -> 12 -> 001 010
            十六进制（四位一组）：1010 -> A -> 1010
    2、码制
        （1）原码
            最高位是符号位，其余低位表示数值的绝对值。
        （2）反码
            正数的反码与原码相同，负数的反码是其绝对值按位取反（符号位不变）。
        （3）补码
            正数的补码与原码相同，负数的补码是其反码的结果加1（符号位不变）。
        （4）移码
            补码的符号位取反。
        注：
            （1）计算机在计算的时候都是用补码进行计算的。
            （2）定点整数（纯整数，无小数）的补码、移码中类似于“1000 0000为最小负数-128而不是-0”这类是人为规定的，也是因为这个原因所以原码、反码的数码个数要比补码、移码的数码个数少1。
            （3）定点小数（纯小数，无整数）的补码、移码中类似于“1000 0000为最小负数-1而不是-0”这类是人为规定的，也是因为这个原因所以原码、反码的数码个数要比补码、移码的数码个数少1。
                数值1       数值-1      数值1 + 数值-1   定点整数范围                   定点小数范围                     数码个数
        原码    0000 0001   1000 0001   1000 0010       -(2^(n-1)-1)到+(2^(n-1)-1)    -(1-2^-(n-1))到+(1-2^-(n-1))    2^n-1
        反码    0000 0001   1111 1110   1111 1111       -(2^(n-1)-1)到+(2^(n-1)-1)    -(1-2^-(n-1))到+(1-2^-(n-1))    2^n-1
        补码    0000 0001   1111 1111   0000 0000       -2^(n-1)到+(2^(n-1)-1)        -1到+(1-2^-(n-1))               2^n
        移码    1000 0001   0111 1111   1000 0000       -2^(n-1)到+(2^(n-1)-1)        -1到+(1-2^-(n-1))               2^n
    3、浮点数
        （1）浮点数表示
            定点整数是全为整数的数；定点小数是全为小数的数；那么浮点数就是即包含整数，又包含小数的数，表示为N = 尾数 * 基数 ^ 阶码。
            ① 一般尾数用补码表示，阶码用移码表示，但是在IEEE754标准中，尾数也可以用原码表示。
            ② 阶码的位数决定数的表示范围，位数越多范围越大。
            ③ 尾数的位数决定数的有效精度，位数越多精度越高。
            ④ 对阶时，一般都是小阶向大阶对齐，因为如果是大阶向小阶对齐，那么势必会导致大阶尾数向左移动，可能会导致最高位丢失，如果反过来则是小阶尾数向右移动，如果丢失也丢失的是最低位，这样误差会小一点。
            ⑤ 对阶是通过小阶的位数右移实现的，如果有符号位，则符号位保持不变，这也叫算术右移。
        （2）运算过程
            对阶（一般小阶向大阶对齐） -> 尾数计算 -> 结果规格化
            规格化：
                直白的来说就是要保证二进制表示时，0.5<=尾数的十进制值要<1（也就是二进制0.11....这种，小数点前只有一位而且是符号位，小数点后面第一位必须要是1），这个作用是为了保证在存储空间不变的前提下尽可能的提高浮点数表示的精度，计算机中是用二进制来存储浮点数的，尾数的存储位数是有限的，如果高位都是0这种属于无效位，反而可能会因为高位存了0，导致后面没有位数来存储本该是低位的数据，从而丢失了，如果也是0那没关系，如果不是0，那就属于精度丢失，这个时候就要用到规格化进行尾数左规，也就是左移，每左移一位阶码就要对应的减1。
    4、逻辑运算
        算术运算符：+，-，*，/
        关系运算符：<，<=，>，>=，==，!=
        赋值运算符：=
        逻辑运算符：
            逻辑与&&，AND（两个都为真才为真）
            逻辑或||，OR（两个中有一个为真就为真）
            逻辑非!，NOT（逻辑值取反）
            逻辑异或⊕，XOR（两个相同为假，不同为真）
        优先级：
            非 > 算术运算符 > 关系运算符 > 与 > 或 > 赋值运算符
        短路原则：
            在逻辑表达式的计算中，并不是所有的逻辑运算符都要被执行。
            （1）a&&b&&c，只要a为假，不会计算后面的值。
            （2）a||b||c，只要a为真，不会计算后面的值。
二、校验码
    1、奇偶校验
    2、CRC循环冗余校验码
    3、海明校验码
三、CPU组成
四、寻址方式
五、CISC与RISC
六、流水线技术
七、存储系统
    1、层次化存储
    2、Cache
    3、主存编址计算
八、输入输出技术
九、总线
十、可靠性
十一、性能指标
十二、操作系统
    1、操作系统的作用
    2、特殊的操作系统
十三、进程
    1、进程的概念
    2、进程的状态
    3、进程的调度
        （1）PV的概念
        （2）信号量与PV操作
        （3）前趋图与PV操作
十四、死锁资源数计算
十五、进程资源图
十六、段页存储
    1、页式存储
    2、段式存储